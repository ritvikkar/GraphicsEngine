<?xml version="1.0" encoding="UTF-8"?>
<material view_color="rgb(0.80000, 0.80000, 0.80000)" sample_lamp="True">
	<nodes>
		<node type="SCRIPT" mode="INTERNAL" script="0" vector="Vector(0.0, 0.0, 0.0)" lightwood="rgba(0.5, 0.20000, 0.06700, 1.0)" darkwood="rgba(0.15000, 0.07699, 0.02800, 1.0)" sharpness="0.10999" ringy="1.0" ringfreq="8.0" ringunevenness="0.30000" ringnoise="0.01999" ringnoisefreq="1.0" grainy="1.0" grainfreq="25.0" trunkwobble="0.15000" trunkwobblefreq="0.02500" angularwobble="1.0" angularwobblefreq="1.5" width="239" loc="-734, 662" />
		<node type="SCRIPT" mode="INTERNAL" script="0" vector="Vector(0.0, 0.0, 0.0)" lightwood="rgba(0.5, 0.20000, 0.06700, 1.0)" darkwood="rgba(0.15000, 0.07699, 0.02800, 1.0)" sharpness="0.00999" ringy="1.0" ringfreq="8.0" ringunevenness="0.5" ringnoise="0.01999" ringnoisefreq="1.0" grainy="1.0" grainfreq="25.0" trunkwobble="0.15000" trunkwobblefreq="0.02500" angularwobble="1.0" angularwobblefreq="1.5" width="239" loc="-736, 82" />
		<node type="BUMP" strength="0.05000" width="140" loc="-444, -54" />
		<node type="BSDF_GLOSSY" hide="True" distribution="BECKMANN" color="rgba(0.80000, 0.80000, 0.80000, 1.0)" roughness="0.20000" width="42" loc="-255, -38" />
		<node type="BSDF_DIFFUSE" hide="True" color="rgba(0.80000, 0.80000, 0.80000, 1.0)" roughness="0.0" width="42" loc="-255, 27" />
		<node type="MIX_SHADER" hide="True" fac="0.5" width="42" loc="-106, 66" />
		<node type="MAPPING" translation="Vector(0.0, 0.0, 0.0)" rotation="Vector(1.57079, 0.0, 0.0)" scale="Vector(1.0, 1.0, 1.0)" use_min="False" use_max="False" vector="Vector(0.0, 0.0, 0.0)" width="320" loc="-1096, -55" />
		<node type="MATH" operation="LESS_THAN" use_clamp="False" value1="0.5" value2="0.89999" width="140" loc="-899, 159" />
		<node type="MATH" operation="MULTIPLY" use_clamp="False" value1="0.5" value2="44.50299" width="140" loc="-918, 522" />
		<node type="VECT_MATH" operation="DOT_PRODUCT" vector1="Vector(0.5, 0.5, 0.5)" vector2="Vector(0.5, 0.5, 0.5)" width="140" loc="-1095, 467" />
		<node type="BUMP" strength="0.30399" width="140" loc="-463, 524" />
		<node type="BSDF_DIFFUSE" hide="True" color="rgba(0.80000, 0.80000, 0.80000, 1.0)" roughness="0.0" width="42" loc="-282, 597" />
		<node type="BSDF_GLOSSY" hide="True" distribution="BECKMANN" color="rgba(0.80000, 0.80000, 0.80000, 1.0)" roughness="0.20000" width="42" loc="-287, 549" />
		<node type="MIX_SHADER" hide="True" fac="0.5" width="42" loc="-155, 623" />
		<node type="MIX_SHADER" fac="0.5" width="140" loc="21, 204" />
		<node type="OUTPUT_MATERIAL" width="140" loc="193, 202" />
		<node type="SCRIPT" mode="INTERNAL" script="1" pos="Vector(0.0, 0.0, 0.0)" scale="0.39999" density="1.70000" falloff="1.40000" knotsize="0.79999" knots="0.30000" distortion="1.89999" width="180" loc="-1388, 260" />
	</nodes>
	<links>
		<link to="1" input="0" from="6" output="0" />
		<link to="8" input="0" from="9" output="1" />
		<link to="0" input="0" from="8" output="0" />
		<link to="14" input="0" from="7" output="0" />
		<link to="15" input="0" from="14" output="0" />
		<link to="2" input="2" from="1" output="3" />
		<link to="10" input="2" from="0" output="3" />
		<link to="3" input="2" from="2" output="0" />
		<link to="4" input="2" from="2" output="0" />
		<link to="5" input="1" from="4" output="0" />
		<link to="5" input="2" from="3" output="0" />
		<link to="4" input="1" from="1" output="2" />
		<link to="3" input="1" from="1" output="2" />
		<link to="5" input="0" from="1" output="1" />
		<link to="3" input="0" from="1" output="0" />
		<link to="4" input="0" from="1" output="0" />
		<link to="14" input="2" from="5" output="0" />
		<link to="13" input="1" from="11" output="0" />
		<link to="13" input="2" from="12" output="0" />
		<link to="11" input="0" from="0" output="0" />
		<link to="12" input="0" from="0" output="0" />
		<link to="12" input="2" from="10" output="0" />
		<link to="11" input="2" from="10" output="0" />
		<link to="11" input="1" from="0" output="2" />
		<link to="12" input="1" from="0" output="2" />
		<link to="14" input="1" from="13" output="0" />
		<link to="13" input="0" from="0" output="1" />
		<link to="7" input="0" from="16" output="1" />
		<link to="6" input="0" from="16" output="0" />
		<link to="9" input="1" from="16" output="0" />
		<link to="9" input="0" from="16" output="0" />
	</links>
	<scripts>
		<script name="MAWoodGrain.osl" id="0">
/*<br /> * MAWoodGrain.osl by Michel J. Anders (c)2012<br /> * from https://github.com/sambler/osl-shaders<br /> *<br /> * license: cc-by-sa<br /> *<br /> * original script from -<br /> * http://blenderthings.blogspot.com.au/2013/01/an-osl-wood-shader-for-blender-cycles.html<br /> *<br /> */<br /><br />#include &quot;stdosl.h&quot;<br /><br />// for the original renderman shader, check http://www.larrygritz.com/arman/materials.html<br /><br />// adapted from larry gritz advanced renderman patterns.h<br />float smoothpulse (float e0, float e1, float e2, float e3, float x)<br />{<br />    return smoothstep(e0,e1,x) - smoothstep(e2,e3,x);<br />}<br /><br />/* A pulse train of smoothsteps: a signal that repeats with a given<br /> * period, and is 0 when 0 &lt;= mod(x/period,1) &lt; edge, and 1 when<br /> * mod(x/period,1) &gt; edge.<br /> */<br />float smoothpulsetrain (float e0, float e1, float e2, float e3, float period, float x)<br />{<br />    return smoothpulse (e0, e1, e2, e3, mod(x,period));<br />}<br /><br />// adapted from larry gritz advanced renderman noises.h<br />/* fractional Brownian motion<br /> * Inputs:<br /> *    p     position<br /> *    octaves        max # of octaves to calculate<br /> *    lacunarity     frequency spacing between successive octaves<br /> *    gain           scaling factor between successive octaves<br /> */<br /><br />/* A vector-valued antialiased fBm. */<br />vector vfBm (point p, float octaves, float lacunarity, float gain)<br />{<br />    float amp = 1;<br />    point pp = p;<br />    vector sum = 0;<br />    float i;<br /><br />    for (i = 0;  i &lt; octaves;  i += 1) {<br />        vector d = snoise(pp);<br />        sum += amp * d;<br />        amp *= gain;<br />        pp *= lacunarity;<br />    }<br />    return sum;<br />}<br /><br />// adapted from larry gritz oak.sl and oak.h<br />// original comments between /* ... */<br />// my comments start with //<br />// note that I dropped the whole filterwidth stuff, partly<br />// because I don't think it necessary in Blender Cycles, partly<br />// because the derivatives and area() function doesn't seem to work (yet)<br />// all specialized snoise defines are replaced by snoise() function calls<br />float oaktexture (point Pshad,<br />    float dPshad,<br />    float ringfreq,<br />    float ringunevenness,<br />    float grainfreq,<br />    float ringnoise,<br />    float ringnoisefreq,<br />    float trunkwobble,<br />    float trunkwobblefreq,<br />    float angularwobble,<br />    float angularwobblefreq,<br />    float ringy,<br />    float grainy)<br />{<br />    /* We shade based on Pshad, but we add several layers of warping: */<br />    /* Some general warping of the domain */<br />    vector offset = vfBm(Pshad*ringnoisefreq, 2, 4, 0.5);<br /><br />    point Pring = Pshad + ringnoise*offset;<br />    /* The trunk isn't totally steady xy as you go up in z */<br />    vector d = snoise(Pshad[2]*trunkwobblefreq) ;<br />    Pring += trunkwobble * d * vector(1,1,0);<br /><br />    /* Calculate the radius from the center. */<br />    float r = hypot(Pring[0], Pring[1]) * ringfreq;<br />    /* Add some noise around the trunk */<br />    r += angularwobble * smoothstep(0,5,r)<br />    * snoise (angularwobblefreq*(Pring)*vector(1,1,0.1));<br /><br />    /* Now add some noise so all rings are not equal width */<br />    r += ringunevenness*snoise(r);<br /><br />    float inring = smoothpulsetrain (0.1, 0.55, 0.7, 0.95, 1, r);<br /><br />    point Pgrain = Pshad*grainfreq*vector(1,1,0.05);<br />    float dPgrain = dPshad; //dropped filterwidthp(Pgrain);<br />    float grain = 0;<br />    float i, amp=1;<br />    for (i = 0;  i &lt; 2;  i += 1) {<br />    float grain1valid = 1-smoothstep(0.2,0.6,dPgrain);<br />        if (grain1valid &gt; 0) {<br />            float g = grain1valid * snoise (Pgrain);<br />            g *= (0.3 + 0.7*inring);<br />            g = pow(clamp(0.8 - (g),0,1),2);<br />            g = grainy * smoothstep (0.5, 1, g);<br />            if (i == 0)<br />                inring *= (1-0.4*grain1valid);<br />            grain = max (grain, g);<br />        }<br />        Pgrain *= 2;<br />        dPgrain *= 2;<br />        amp *= 0.5;<br />    }<br /><br />    return mix (inring*ringy, 1, grain);<br />}<br /><br />// larry gritz' original shader was a closure but this shader<br />// provides different outputs that you can plug into your own<br />// closures/shaders<br />surface oak(<br />        point Vector = P,<br />        color LightWood = color(0.5, 0.2, 0.067),<br />        color DarkWood = color(0.15, 0.077, 0.028),<br />        float Sharpness = 0.01, // sharpness of the grain. hand tweaked because we lack derivatives.<br />        float Ringy = 1.0,<br />        float RingFreq = 8.0,<br />        float RingUnevenness = 0.5,<br />        float RingNoise = 0.02,<br />        float RingNoiseFreq = 1.0,<br />        float Grainy = 1.0,<br />        float GrainFreq = 25.0,<br />        float TrunkWobble = 0.15,<br />        float TrunkWobbleFreq = 0.025,<br />        float AngularWobble = 1.0,<br />        float AngularWobbleFreq = 1.5,<br />        output color Color = 0,<br />        output float Specular = 0.1,<br />        output float Roughness = 0.1,<br />        output float Displacement = 0.0  )<br />{<br />    float wood = oaktexture (Vector, Sharpness, RingFreq, RingUnevenness, GrainFreq,<br />            RingNoise, RingNoiseFreq, TrunkWobble, TrunkWobbleFreq,<br />            AngularWobble, AngularWobbleFreq, Ringy, Grainy);<br /><br />    Color = mix (LightWood, DarkWood, wood);<br />    Displacement = -wood;  // lightwood = 0, darkwood is deeper/lower = -1<br />    Specular = 0.1*(1.0-0.5*wood); // darkwood is less specular<br />    Roughness = 0.1+0.1*wood; // and rougher<br />}<br /><br />
		</script>
		<script name="MAWoodKnots2.osl" id="1">
/*<br /> * MAWoodKnots2.osl by Michel J. Anders (c)2013<br /> * from https://github.com/sambler/osl-shaders<br /> *<br /> * license: cc-by-sa<br /> *<br /> * original script from -<br /> * http://blenderthings.blogspot.com.au/2013/07/OSL-wood-shader-with-knots-for-Blender-Cycles.html<br /> *<br /> */<br /><br />#include &quot;stdosl.h&quot;<br /><br />vector random_sphere(point p, int n, float zdistribution){<br />    float t = M_2PI*noise(&quot;cell&quot;,p,n*2+0);<br />    float u = 2*noise(&quot;cell&quot;,p,n*2+1)-1;<br />    float s,c,a;<br />    sincos(t,s,c);<br />    a = sqrt(1-u*u);<br />    float x = a*c;<br />    float y = a*s;<br />    float z = u*zdistribution;<br />    return vector(x,y,z);<br />}<br /><br />int bend(vector p, vector k, vector kv, float r, float a, float m, output vector B){<br />    vector pk = k - p;<br />    vector t = dot(pk,kv)/dot(kv,kv);<br />    vector D = k + t * kv - p;<br />    float L = length(D);<br />    if( L &lt; r ){<br />        float c = L/r;<br />        float d = m * pow( 1 - c , a);<br />        if( d &lt; L ){<br />            B = d * normalize(D);<br />            return 1;<br />        }else{<br />            B = D;<br />            return 2;<br />        }<br />    }<br />    return 0;<br />}<br /><br />shader MAWoodKnots2(<br />  vector Pos = P,<br />  float Scale = 1.5,<br /><br />  float Density = 2.9,<br />  float Falloff = 2.0,<br />  float Knots=0.1,<br />  float KnotSize = 1.0,<br />  float Distortion=1.0,<br /><br />  output vector Vec = P,<br />  output float Fac = 0 )<br />{<br />    vector p = Scale * Pos;<br />    vector sdp = 0;<br /><br />    float TR = ceil(Density);<br />    for(float dx=-TR; dx &lt;= TR; dx++){<br />        for(float dy=-TR; dy &lt;= TR; dy++){<br />            for(float dz=-TR; dz &lt;= TR; dz++){<br />                vector ip = floor(p)+vector(dx,dy,dz);<br />                for(int ik=0; ik &lt; (int)Knots; ik++){<br />                    vector k = noise(&quot;cell&quot;,ip,ik);<br />                    vector kv= random_sphere(ip,ik+1000,Distortion);<br />                    vector dp= 0;<br />                    int ret = bend(p,ip+k,kv,Density,Falloff,KnotSize,dp);<br />                    if(ret != 0){<br />                        Fac=max(Fac,ret==2);<br />                        sdp+=dp;<br />                    }<br />                }<br />                if( noise(&quot;cell&quot;,ip,-1) &lt; mod(Knots,1.0) ){<br />                    vector k = noise(&quot;cell&quot;,ip,-2);<br />                    vector kv= random_sphere(ip,998,Distortion);<br />                    vector dp= 0;<br />                    int ret = bend(p,ip+k,kv,Density,Falloff,KnotSize,dp);<br />                    if(ret != 0){<br />                        Fac=max(Fac,ret==2);<br />                        sdp+=dp;<br />                    }<br />                }<br />            }<br />        }<br />    }<br />    if( Fac &lt; 1 ){<br />        Vec = p + sdp;<br />    }else{<br />        Vec = sdp;<br />    }<br />}<br />
		</script>
	</scripts>
</material>