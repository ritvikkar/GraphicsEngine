<?xml version="1.0" encoding="UTF-8"?>
<material view_color="rgb(0.80000, 0.80000, 0.80000)" sample_lamp="True">
	<nodes>
		<node type="OUTPUT_MATERIAL" width="140" loc="142, 287" />
		<node type="TEX_COORD" dupli="False" width="140" loc="-642, 268" />
		<node type="TEX_NOISE" scale="5.0" detail="2.0" distortion="0.0" width="140" loc="-814, 49" />
		<node type="MATH" operation="MULTIPLY" use_clamp="False" value1="0.5" value2="0.04999" width="140" loc="-643, 45" />
		<node type="BSDF_DIFFUSE" color="rgba(0.80000, 0.80000, 0.80000, 1.0)" roughness="0.0" width="150" loc="-37, 292" />
		<node type="VECT_MATH" operation="ADD" vector1="Vector(0.5, 0.5, 0.5)" vector2="Vector(0.5, 0.5, 0.5)" width="140" loc="-451, 192" />
		<node type="SCRIPT" mode="INTERNAL" script="0" vector="Vector(0.0, 0.0, 0.0)" scale="8.0" basecolor="rgba(0.79000, 0.68000, 0.36000, 1.0)" shape="0.30000" ratio="160.0" radius="2.59999" innernoise="0.10000" innernoiseseed="5.0" innercolor="rgba(0.67000, 0.25, 0.10999, 1.0)" outersize="1.10000" outerblur="-2.09999" outercolor="rgba(0.01200, 0.00100, 0.00700, 1.0)" centreprobability="0.30000" centreradius="0.40000" centercolor="rgba(0.04600, 0.03799, 0.03599, 1.0)" width="194" loc="-263, 291" />
	</nodes>
	<links>
		<link to="5" input="1" from="3" output="0" />
		<link to="3" input="0" from="2" output="1" />
		<link to="5" input="0" from="1" output="2" />
		<link to="0" input="0" from="4" output="0" />
		<link to="6" input="0" from="5" output="0" />
		<link to="4" input="0" from="6" output="0" />
	</links>
	<scripts>
		<script name="MABLeopard.osl" id="0">
/*<br /> * MABLeopard.osl by Michel J. Anders (c)2013<br /> * from https://github.com/sambler/osl-shaders<br /> *<br /> * license: gplv3<br /> *<br /> * original script from -<br /> * Open Shading Language for Blender by Michel J. Anders<br /> *<br /> */<br /><br />#include &quot;stdosl.h&quot;<br /><br />// bubble sort. fast enough<br />// for small collections<br />void sort(int np,<br />    output point p[],<br />    output float f[] )<br />{<br />    int n = np;<br />    for(int j = 0; j &lt; np; j++){<br />        for(int i = 1; i &lt; n; i++){<br />            if( f[i-1] &gt; f[i] ){<br />                float tf = f[i-1];<br />                f[i-1] = f[i];<br />                f[i] = tf;<br />                point tp = p[i-1];<br />                p[i-1] = p[i];<br />                p[i] = tp;<br />            }<br />        }<br />        n--;<br />    }<br />}<br /><br />void voronoip9d(<br />    point q,<br />    float T,<br />    output point vp[9],<br />    output float vd[9] )<br />{<br />    point p = point(q[0],q[1],0);<br /><br />    float xx, yy, xi, yi;<br /><br />    xi = floor(p[0]);<br />    yi = floor(p[1]);<br /><br />    int i = -1;<br />    for(xx = xi-1; xx &lt;= xi+1; xx++){<br />        for(yy = yi-1; yy &lt;= yi+1; yy++){<br />            i++;<br />            vector ip = vector(xx, yy, 0);<br />            vector np = cellnoise(ip);<br />            vp[i] = ip + np * T + vector((1-T)/2,(1-T)/2,0);<br />            vp[i][2] = 0;<br />            vector dp = vp[i] - p;<br />            vd[i] = dp[0] * dp[0] + dp[1] * dp[1];<br />        }<br />    }<br />    sort(9,vp,vd);<br />}<br /><br />void voronoip8a(<br />    point q,<br />    float T,<br />    output point vp[8],<br />    output float angles[8] )<br />{<br />    point p = point(q[0],q[1],0);<br /><br />    float xx, yy, xi, yi;<br /><br />    xi = floor(p[0]);<br />    yi = floor(p[1]);<br /><br />    int i = -1;<br />    for(xx = xi-1; xx &lt;= xi+1; xx++){<br />        for(yy = yi-1; yy &lt;= yi+1; yy++){<br />            vector ip = vector(xx, yy, 0);<br />            vector np = cellnoise(ip);<br />            np[2] = 0;<br />            vector vvp = ip + np * T + vector((1-T)/2,(1-T)/2,0);<br />            vector d = vvp-p;<br />            if( dot(d,d) &gt; 1e-7 ){<br />                float angle = atan2(d[1],d[0]);<br />                i++;<br />                vp[i] = vvp;<br />                angles[i] = angle;<br />            }<br />        }<br />    }<br />    sort(8,vp,angles);<br />}<br /><br />int closest_convex_polygon(<br />    point c0,<br />    point vp[8],<br />    output point mp[8] )<br />{<br />    int imp[8] = {0, 1};<br />    int nmp = 2;<br /><br />    int delauney(int b, int c, int d)<br />    {<br />        float alpha = acos(<br />        dot(vp[b]-vp[c], vp[b]-c0));<br />        float gamma = acos(dot(vp[d]-vp[c],vp[d]-c0));<br />        return (alpha+gamma) &lt;= M_PI;<br />    }<br /><br />    for(int i = 2; i &lt; 8; i++){<br />        if( delauney(imp[nmp-2], imp[nmp-1], i) )<br />        {<br />            imp[nmp] = i;<br />            nmp++;<br />        }else{<br />            imp[nmp-1] = i;<br />        }<br />    }<br />    while( (nmp &gt; 3) &amp;&amp; !delauney(imp[nmp-2], imp[nmp-1], imp[0]) )<br />    {<br />        nmp--;<br />    }<br /><br />    for(int i = 0; i &lt; nmp; i++){<br />        mp[i] = vp[imp[i]];<br />    }<br />    return nmp;<br />}<br /><br />int point_inside_polygon(<br />    point p,<br />    point verts[],<br />    int nverts,<br /><br />    output float sumangle )<br />{<br />    int i;<br />    sumangle = 0;<br />    vector ref = normalize(verts[0]-p);<br />    vector ref2;<br />    float amod;<br />    for(i = 1; i &lt; nverts; i++){<br />        ref2 = normalize(verts[i]-p);<br />        sumangle += acos(dot(ref, ref2));<br />        ref = ref2;<br />    }<br />    ref2 = normalize(verts[0]-p);<br />    sumangle += acos(dot(ref, ref2));<br />    amod = abs(mod(sumangle,M_2PI));<br /><br />    return (amod &lt; 1e-2) || (M_2PI - amod &lt; 1e-2);<br />}<br /><br />shader MABLeopard(<br />    point Vector = P,<br />    float Scale = 3.0,<br /><br />    color BaseColor = color(0.79,0.68,0.36),<br /><br />    float Shape = 0.3, // shape variation<br />    float Ratio = 160, // ratio between inner and outer<br />    float Radius = 2.6, // size of inner spot<br /><br />    float InnerNoise = 0.1, // amount on noise within the inner spot<br />    float InnerNoiseSeed = 5.0,<br />    color InnerColor = color(0.67,0.25,0.11),<br /><br />    float OuterSize = 1.4, // size of spots around the edge<br />    float OuterBlur = -2.1, // amount of blur between outer spots<br />    color OuterColor = color(0.012,0.001,0.007),<br /><br />    float CentreProbability = 0.2, // chance of another spot in centre<br />    float CentreRadius = 0.2, // size of centre spot<br />    color CenterColor = color(0.046,0.038,0.036),<br /><br />    // Debug helpers<br />    //output float D = 0,<br />    //output float Edge = 0<br /><br />    output color Color = OuterColor )<br />{<br />    point p = Vector * Scale;<br />    p[2] = 0;<br />    point vp[9];<br />    float dp[9];<br /><br />    voronoip9d(p,Shape, vp, dp);<br /><br />    point nvp[8];<br />    float angles[8];<br />    voronoip8a(vp[0], Shape, nvp, angles);<br /><br />    point mp[8];<br />    int m = closest_convex_polygon(vp[0], nvp, mp);<br /><br />    float sump = 0;<br />    float mind = 1e7;<br /><br />    point mmp[8];<br />    for(int i = 0; i &lt; m; i++){<br />        mmp[i] = mix(vp[0], mp[i], Radius/10);<br />        float d = distance(mmp[i], p);<br />        sump += OuterSize * pow(d, OuterBlur);<br />        d = distance(vp[0], mp[i]);<br />        if( d &lt; mind ){ mind = d; }<br />    }<br /><br />    if( noise(&quot;cell&quot;,p) &lt; CentreProbability &amp;&amp; dp[0] &lt; (CentreRadius*.01) ){<br />        Color = CenterColor;<br />    }else if( sump &lt; Ratio ){<br />        float sumangle;<br />        if(point_inside_polygon(p + noise(&quot;snoise&quot;,InnerNoiseSeed * p)* (InnerNoise*.01), mmp, m, sumangle) ){<br />            Color = InnerColor;<br />        }else{<br />            Color = BaseColor;<br />        }<br />    }<br /><br />    // Debug helpers<br />    // also enable shader outputs for these<br /><br />    // the distance from the<br />    // center of the rosette<br />    //D = dp[0];<br /><br />    // for debugging, highlight<br />    // the edge of a cell<br />    //if ( mod(p[0],1.0) &lt; 0.02 || mod(p[1],1.0) &lt; 0.02){<br />    //    Edge = 1;<br />    //}<br />}<br />
		</script>
	</scripts>
</material>