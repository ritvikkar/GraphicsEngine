<?xml version="1.0" encoding="UTF-8"?>
<material name="MAB13CastIronCover" view_color="rgb(0.80000, 0.80000, 0.80000)" sample_lamp="True">
	<nodes>
		<node type="SCRIPT" mode="INTERNAL" script="0" vector="Vector(0.0, 0.0, 0.0)" scale="4.0" height="100" width="152" width_hidden="42" loc="391, 360" />
		<node type="MATH" operation="MULTIPLY" use_clamp="False" value1="0.06199" value2="0.5" height="100" width="140" width_hidden="42" loc="395, 144" />
		<node type="MATH" operation="LESS_THAN" use_clamp="False" value1="0.5" value2="0.00499" height="100" width="140" width_hidden="42" loc="594, 355" />
		<node type="MATH" operation="ADD" use_clamp="False" value1="0.5" value2="0.5" height="100" width="140" width_hidden="42" loc="589, 147" />
		<node type="BSDF_GLOSSY" distribution="BECKMANN" color="rgba(0.80000, 0.80000, 0.80000, 1.0)" roughness="0.10000" height="100" width="150" width_hidden="42" loc="998, 179" />
		<node type="BSDF_TRANSPARENT" color="rgba(1.0, 1.0, 1.0, 1.0)" height="100" width="140" width_hidden="42" loc="1211, 185" />
		<node type="MIX_SHADER" fac="0.5" height="100" width="140" width_hidden="42" loc="1435, 268" />
		<node type="BSDF_DIFFUSE" color="rgba(0.01953, 0.01953, 0.01953, 1.0)" roughness="0.39999" height="100" width="150" width_hidden="42" loc="1005, 351" />
		<node type="BUMP" strength="1.0" height="100" width="140" width_hidden="42" loc="786, 182" />
		<node type="MIX_SHADER" fac="0.20000" height="100" width="140" width_hidden="42" loc="1215, 346" />
		<node type="MAPPING" translation="Vector(0.0, 0.0, 0.0)" rotation="Vector(0.0, 0.0, 0.0)" scale="Vector(0.5, 0.5, 0.5)" use_min="False" use_max="False" vector="Vector(0.0, 0.0, 0.0)" height="100" width="320" width_hidden="42" loc="13, 366" />
		<node type="TEX_NOISE" scale="109.35199" detail="2.0" distortion="0.0" height="100" width="140" width_hidden="42" loc="191, 55" />
		<node type="REROUTE" height="100" width="16" width_hidden="42" loc="1011, 208" />
		<node type="TEX_COORD" dupli="False" height="100" width="140" width_hidden="42" loc="-184, 278" />
		<node type="OUTPUT_MATERIAL" height="100" width="120" width_hidden="42" loc="1630, 267" />
	</nodes>
	<links>
		<link to="10" input="0" from="13" output="2" />
		<link to="2" input="0" from="0" output="0" />
		<link to="1" input="1" from="11" output="1" />
		<link to="3" input="1" from="1" output="0" />
		<link to="3" input="0" from="0" output="0" />
		<link to="8" input="2" from="3" output="0" />
		<link to="9" input="1" from="7" output="0" />
		<link to="9" input="2" from="4" output="0" />
		<link to="7" input="2" from="8" output="0" />
		<link to="4" input="2" from="8" output="0" />
		<link to="6" input="2" from="5" output="0" />
		<link to="6" input="1" from="9" output="0" />
		<link to="14" input="0" from="6" output="0" />
		<link to="6" input="0" from="12" output="0" />
		<link to="0" input="0" from="10" output="0" />
		<link to="12" input="0" from="2" output="0" />
	</links>
	<scripts>
		<script name="MABCastIronCover.osl" id="0">
/*<br /> * MABCastIronCover.osl by Michel J. Anders (c)2013<br /> * from https://github.com/sambler/osl-shaders<br /> *<br /> * license: gplv3<br /> *<br /> * original script from -<br /> * Open Shading Language for Blender by Michel J. Anders<br /> *<br /> */<br /><br />#include &quot;stdosl.h&quot;<br /><br />int incircle(float x, float y, float r, float cx, float cy){<br />    float rx = x - cx;<br />    float ry = y - cy;<br />    return rx*rx+ry*ry &lt; r*r;<br />}<br /><br />point rotate_90(point p){<br />    vector v = vector(0.5, 0.5, 0);<br />    point q = p - v;<br />    q=point(q[1],-q[0],0);<br />    return q+v;<br />}<br /><br />point rotate_180(point p){<br />    return point(1-p[0],1-p[1],p[2]);<br />}<br /><br />point mirror_h(point p){<br />    return point(1-p[0],p[1],p[2]);<br />}<br /><br />point mirror_v(point p){<br />    return point(p[0],1-p[1],p[2]);<br />}<br /><br />point mirror_xy(point p){<br />    return point(p[1],p[0],p[2]);<br />}<br /><br />point mirror_line(<br />    point p,<br />    float a,<br />    float b )<br />{<br />    float Mx = abs(b) &gt; 1e-7 ? (b * p[1] + p[0] - a * b) / (b * b + 1) : p[0];<br />    float My = a + b * Mx;<br />    return point(2 * Mx - p[0], 2 * My - p[1], 0);<br />}<br /><br />void rosette(<br />    point Pos,<br />    output float Fac )<br />{<br />    Fac = 1;<br /><br />    point p = Pos;<br />    if(p[0] &gt; 0.5){<br />        p = mirror_h(p);<br />    }<br />    if(p[1] &gt; 0.5){<br />        p = mirror_v(p);<br />    }<br />    if(p[1] &gt; p[0] ){<br />        p = mirror_xy(p);<br />    }<br /><br />    float a=0.3;<br />    float b=135;<br />    float w=0.12;<br /><br />    if( p[1]&gt;w &amp;&amp; !incircle(p[0], p[1], 0.5-w/2, 0.5, 0.0) ){<br />        Fac = 0;<br />    } else if(incircle(p[0], p[1]*(1+0.5-p[0]), w/2, 0.5,0.5-1.2*w)){<br />        Fac = 0;<br />    } else {<br />        if( p[1]+0.5 &gt; p[0]*2){<br />            p = mirror_line(p,-0.5,2);<br />        }<br />        float x = p[0]-0.5+w/2;<br />        if ((p[1]-2*w)*a &lt; -x*x*x*b){<br />            Fac = 0;<br />        }<br />    }<br />}<br /><br />void lily(<br />    point p,<br />    output float Fac )<br />{<br />    float x = p[0];<br />    float y = p[1];<br /><br />    Fac = 0;<br /><br />    float w = 0.12;<br /><br />    if (y &lt; w/2 ) { return; }<br /><br />    y -= w/2;<br /><br />    if ( x &gt; 0.5 ) { x = 1 - x; }<br /><br />    if ( y &gt; 0.5 ) { return; }<br /><br />    if ( y &lt; x - 0.05 ) { return; }<br /><br />    if ( incircle(x,y,0.1,0.15,0) ){<br />        return;<br />    }<br /><br />    if(!incircle(x,y,0.15,0.15,0) ){<br />        if(y &gt;0.05*cos(x*30)+0.2-x ){<br />            return;<br />        }<br />    }<br />    Fac = 1;<br />}<br /><br />float dottedcircle(<br />    point p,<br />    float cx, float cy,<br />    float r, float w, int n )<br />{<br />    float Fac = 0;<br /><br />    float e = w/4;<br />    float x = p[0], y = p[1];<br />    if( incircle(x,y,r ,cx,cy) &amp;&amp; !incircle(x,y,r-w,cx,cy)){<br />        if(incircle(x,y,r-e,cx,cy) &amp;&amp; !incircle(x,y,r-w+e,cx,cy)){<br />            Fac = 0.5;<br />            for(int i = 0; i &lt; n; i++){<br />                float s,c;<br />                float angle = radians(i*360/n);<br />                float m = r - w/2;<br />                sincos(angle,s,c);<br />                if(incircle(x,y,e,cx+m*s,cy+m*c)){<br />                    Fac = 1;<br />                    break;<br />                }<br />            }<br />        }else{<br />            Fac = 1;<br />        }<br />    }<br />    return Fac;<br />}<br /><br />void slant(<br />    float coord,<br />    float limit,<br />    output float Fac )<br />{<br />    if( Fac &gt; 0 &amp;&amp; coord &lt; limit){<br />        Fac -= 0.2*(limit-coord)/limit;<br />    }<br />}<br /><br />void dottedband(<br />    point q,<br />    output float Fac )<br />{<br />    Fac = 0;<br /><br />    float rs = 0.15, rl = 0.43;<br />    float w = 0.08;<br /><br />    if(q[1] &gt; 0.5){ q = rotate_180(q); }<br />    if(q[0] &gt; 0.5){ q = rotate_90(q); }<br /><br />    // small up curl<br />    Fac = dottedcircle(q,0,0.5,rs,w,12);<br />    slant(q[0], rs-w, Fac);<br /><br />    // main circle<br />    if( Fac == 0 ){<br />        Fac=dottedcircle(q, 0.5, 0.5, rl, w, 36);<br />        slant(q[0], rl-2*w, Fac);<br />    }<br /><br />    // small down curl<br />    if( Fac == 0 ){<br />        Fac=dottedcircle(q, 0.5, 0.0, rs, w, 12);<br />        slant(q[1], rs-w, Fac);<br />    }<br />}<br /><br /><br />void dottededge(<br />    point p,<br />    output float Fac )<br />{<br />    Fac = 0;<br /><br />    float Ndots = 15;<br />    if(p[1] &lt; 0.08){<br />        if(p[1] &lt; 0.015 || p[1] &gt; 0.065){<br />            Fac = 1;<br />        }else{<br />            if(incircle(mod(p[0],1/Ndots),p[1],0.02,(1/Ndots)/2,0.04)){<br />                Fac = 1;<br />            }else{<br />                Fac = 0.5;<br />            }<br />        }<br />    }<br />}<br /><br />shader MABCastIronCover(<br />    point Vector = P,<br />    float Scale = 1,<br /><br />    output float Fac = 0 )<br />{<br />    point p = mod(Vector * Scale, 1.0);<br /><br />    if(p[1] &gt; 0.5){<br />        p = rotate_180(p);<br />    }<br /><br />    p *= 2;<br /><br />    if( p[1] &lt; 1 ) {<br />        lily(mod(p, 1.0), Fac);<br />    }<br /><br />    if( Fac == 0 ){<br />        rosette(mod(p, 1.0), Fac);<br />    }<br /><br />    if( Fac == 0 ){<br />        dottedband(mod(p, 1.0), Fac);<br />    }<br /><br />    if( Fac == 0){<br />        if(p[1] &gt; 0.5){<br />            rosette(mod(p-0.5, 1.0), Fac);<br />        }<br />    }<br /><br />    if( Fac == 0 ){<br />        dottededge(p, Fac);<br />    }<br />}<br />
		</script>
	</scripts>
</material>