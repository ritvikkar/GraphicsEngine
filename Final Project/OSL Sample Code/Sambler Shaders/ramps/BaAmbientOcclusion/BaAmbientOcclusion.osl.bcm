<?xml version="1.0" encoding="UTF-8"?>
<material view_color="rgb(0.80000, 0.80000, 0.80000)" sample_lamp="True">
	<nodes>
		<node type="BSDF_DIFFUSE" color="rgba(0.28342, 0.28401, 0.80000, 1.0)" roughness="0.0" loc="90, 310" />
		<node type="OUTPUT_MATERIAL" loc="284, 304" />
		<node type="SCRIPT" mode="INTERNAL" script="0" effect="rgba(0.0, 0.0, 0.0, 1.0)" no_effect="rgba(0.28342, 0.28401, 0.80000, 1.0)" mode="0" inverteffect="0" distance="25.0" samples="6" loc="-121, 340" />
	</nodes>
	<links>
		<link to="1" input="0" from="0" output="0" />
		<link to="0" input="0" from="2" output="0" />
	</links>
	<scripts>
		<script name="BaAmbientOcclusion.osl" id="0">
/*<br /> * BaVelvet.osl by Bao2 (c)2012<br /> * from https://github.com/sambler/osl-shaders<br /> *<br /> * original script from -<br /> * http://blenderartists.org/forum/showthread.php?270332-OSL-Goodness/page10<br /> *<br /> */<br /><br />/* Original code from Brecht:<br />   http://projects.blender.org/scm/viewvc.php?view=rev&amp;root=bf-blender&amp;revision=51952<br />   <br />   Mode: 0: Concave (AO) <br />         1: Convex (Wear) <br />         2: Both<br />         <br />   InvertEffect: Swaps Effect and No_Effect colors<br />   <br />   Samples: 1 or above (set 0 or negative to turn off the effect)<br />   <br />   Output Color: Mix between the two colors driven by Fac<br />   Output Fac: Exposed because it can be useful to have it too<br />*/<br /><br />#include &quot;stdosl.h&quot;<br /><br />void rng_seed(output int rng, int seed)<br />{<br />  int chash = seed;<br />  if (chash == 0) chash = 1;<br />  rng = chash * 891694213;<br />}<br /><br />float rng_uniform(output int rng)<br />{<br />  float res = rng / float(2137483647) * 0.5 + 0.5;<br />  rng *= 891694213;<br />  return res;<br />}<br /><br />void to_unit_disk(float x, float y, output float x_out, output float y_out)<br />{<br />  float r, phi;<br />  float a = 2.0 * x - 1.0;<br />  float b = 2.0 * y - 1.0;<br />    <br />  if(a &gt; -b) {<br />    if(a &gt; b) {<br />      r = a;<br />      phi = M_PI_4 *(b/a);<br />    }<br />    else {<br />      r = b;<br />      phi = M_PI_4 *(2.0 - a/b);<br />    }<br />  }<br />  else {<br />    if(a &lt; b) {<br />      r = -a;<br />      phi = M_PI_4 *(4.0 + b/a);<br />    }<br />    else {<br />      r = -b;<br />      if(b != 0.0) phi = M_PI_4 *(6.0 - a/b);<br />      else phi = 0.0;<br />    }<br />  }<br />  x_out = r * cos(phi);<br />  y_out = r * sin(phi);<br />}<br /><br />void make_orthonormals(vector N, output vector a, output vector b)<br />{<br />  if(N[0] != N[1] || N[0] != N[2]) a = cross(vector(1, 1, 1), N);<br />  else a = cross(vector(-1, 1, 1), N);<br />  <br />  a = normalize(a);<br />  b = cross(N, a);<br />}<br /><br />vector sample_cos_hemisphere(vector N, float randu, float randv)<br />{<br />  vector T, B;<br />    <br />  make_orthonormals(N, T, B);<br />  to_unit_disk(randu, randv, randu, randv);<br />  float costheta = sqrt(max(1.0 - randu * randu - randv * randv, 0.0));<br /><br />  return randu * T + randv * B + costheta * N;<br />}<br /><br />shader BaAmbientOcclusion(<br />  color Effect = color(0),<br />  color No_Effect = color(1),<br />  int Mode = 0, /* 0: Concave (AO) 1:Convex (Wear) 2:Both */<br />  int InvertEffect = 0,<br />  float Distance = 0.2,<br />  int Samples = 1,<br />  output color Color = 0,<br />  output float Fac = 0 )<br />{<br />  int i, rng;<br />  float f, randu, randv, ray_t, hits = 0;<br />  vector ray_P, ray_R;<br /><br />  f = fmod(cellnoise(P*123456.0), 1.0);<br />  rng_seed(rng, int(f * 2137483647));<br />  <br />  for(i = 0; i &lt; Samples; i++) {<br />    randu = rng_uniform(rng);<br />    randv = rng_uniform(rng);<br />    <br />    ray_P = P;<br />    ray_R = sample_cos_hemisphere(-N, randu, randv);<br />    ray_t = Distance;<br />        <br />    if (!Mode) {<br />      if(trace(ray_P, -ray_R, &quot;maxdist&quot;, ray_t)) hits += 1.0;<br />    }<br />    else if (Mode == 1) {<br />      if(trace(ray_P, ray_R, &quot;maxdist&quot;, ray_t)) hits += 1.0;<br />    }<br />    else {<br />      if(trace(ray_P, -ray_R, &quot;maxdist&quot;, ray_t)) hits += 1.0;<br />      if(trace(ray_P, ray_R, &quot;maxdist&quot;, ray_t)) hits += 1.0;<br />    }<br />  }<br />  Fac = 1.0 - (hits/Samples);<br />  if(InvertEffect) Color = mix(No_Effect, Effect, Fac);<br />  else Color = mix(Effect, No_Effect, Fac);<br />}<br /><br />
		</script>
	</scripts>
</material>