<?xml version="1.0" encoding="UTF-8"?>
<material view_color="rgb(0.80000, 0.80000, 0.80000)" sample_lamp="True">
	<nodes>
		<node type="BSDF_DIFFUSE" color="rgba(0.28342, 0.28401, 0.80000, 1.0)" roughness="0.0" width="150" loc="-517, 276" />
		<node type="OUTPUT_MATERIAL" width="120" loc="8, 350" />
		<node type="BSDF_DIFFUSE" color="rgba(0.80000, 0.08092, 0.05845, 1.0)" roughness="0.0" width="150" loc="-523, 145" />
		<node type="SCRIPT" mode="INTERNAL" script="0" colorin="rgba(1.0, 1.0, 1.0, 1.0)" colorhit="rgba(0.0, 0.0, 0.0, 1.0)" ao_angle="0.94999" maxdistance="25.0" normalbump="Vector(0.0, 0.0, 0.0)" width="140" loc="-252, 358" />
	</nodes>
	<links>
		<link to="1" input="0" from="3" output="1" />
		<link to="3" input="2" from="0" output="0" />
		<link to="3" input="3" from="2" output="0" />
	</links>
	<scripts>
		<script name="FGgao_ambient_occlusion.osl" id="0">
/*<br /> * FGgao_ambient_occlusion.osl by François GASTALDO<br /> * from https://github.com/sambler/osl-shaders<br /> *<br /> * original script from -<br /> * http://vadrouillegraphique.blogspot.fr/<br /> *<br /> */<br /><br />/* This program is free software; you can redistribute it and/or<br /> * modify it under the terms of the GNU General Public License<br /> * as published by the Free Software Foundation; either version 2<br /> * of the License, or (at your option) any later version.<br /> *<br /> * This program is distributed in the hope that it will be useful,<br /> * but WITHOUT ANY WARRANTY; without even the implied warranty of<br /> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the<br /> * GNU General Public License for more details.<br /> *<br /> * You should have received a copy of the GNU General Public License<br /> * along with this program; if not, write to the Free Software Foundation,<br /> * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.<br /> */<br /> <br /> /* Simple Ambient Occlusion<br />  * <br />  * by François GASTALDO<br />  *<br />  * contact me at : pressf9@free.fr<br />  *<br />  * blog (3D, shaders, photos and more) : http://vadrouillegraphique.blogspot.fr/<br />  *<br />  * Small Documentation :<br />	This shader is a general purpose Ambient Occlusion<br />	<br />	You can use it for color or for closure, or for both at same time.<br />	<br />	if you connect use just the ' ColorIn ' or just the ' closureIn ' inputs<br />	and connect nothing to 'ColorHit' or 'closureHit'. then Occlusion will be black.<br />	<br />	AO Angle is in RADIANS,  1.0 = 180° AO search <br />  <br />	Maxdistance limit distance of occluding objects.<br />  <br />  * This shader is made for educationnal purpose only. Use it in production at your own risk.<br />  *<br />  * Closures are for Blender/Cycles. They could need adaptation for your renderer.<br />  *<br />  * If you use this shader, please credit it and me. Thank you.<br />  *<br />  *  Enjoy !<br />  *<br />  * François Gastaldo<br />  */<br /> <br />#include &quot;stdosl.h&quot;<br />#include &quot;node_fresnel.h&quot;<br />#include &quot;oslutil.h&quot;<br /><br />shader FGgao_ambient_occlusion(<br />    color ColorIn = color(1.0,1.0,1.0),<br />    color ColorHit = color(0.0 , 0.0 , 0.0 ),<br />    closure color closureIn = color(1.0,1.0,1.0) * emission() ,<br />    closure color closureHit = 0.0 ,<br />    float AO_Angle = 0.95 ,<br />    float maxDistance = 25.0 ,<br />    vector Normalbump = vector (0.0 , 0.0 , 0.0),<br />    output color CoulOut = color(1.0,0.0,0.0) ,<br />    output closure color closureOut = closureIn)<br />{<br />    // Disable diffuse emission from this material<br />    <br />    int RTdiffuse = raytype (&quot;diffuse&quot;);<br />    <br />    if (  RTdiffuse ) {<br />        //closure color NullClosure = 0.0;<br />        CoulOut =ColorIn;<br />        closureOut =   closureIn  ;<br /><br />        // If you want to make AO without indirect illumination, activate this line.<br />        //closureOut =   NullClosure;<br />    } else {<br />        // compute  vector to trace Ray = random * N<br />        vector bruitvector = vector ( 0.0 , 0.0 , 0.0 );<br />        vector VectorAO =  N  + Normalbump + (0.001 * noise(&quot;perlin&quot;, P*10000.0 ));<br /><br />        if ( AO_Angle != 0.0 ){<br />            bruitvector = AO_Angle * ( 1.0- 2.0 * noise(&quot;cell&quot;, VectorAO*10000.0 ) );<br />            VectorAO +=  bruitvector;<br />        }<br /><br />        // Trace Ray  for AO<br />        float Dist = 1.0;<br />        float mixage = 1.0;<br />        vector DirTrace = normalize(VectorAO);<br />        <br />        int DoTrace = trace (P, DirTrace, &quot;maxdist&quot; , maxDistance );<br /><br />        if ( DoTrace) {<br />            // If hit something<br />            int HitTrace = getmessage (&quot;trace&quot;, &quot;hitdist&quot; ,  Dist );<br /><br />            mixage = clamp ( (Dist / maxDistance) , 0.0 , 1.0 );<br /><br />            // make a gradient between the 2 colors to have smoother (and better quality) AO.<br />            CoulOut = mix  ( ColorHit , ColorIn , mixage );<br />            closureOut = (closureIn * mixage)  + closureHit * (1.0 - mixage );<br />           <br />        } else {<br />            // else, return black<br />            CoulOut = ColorIn;<br />            closureOut = closureIn;<br />        }<br />    }<br />}<br /><br />
		</script>
	</scripts>
</material>