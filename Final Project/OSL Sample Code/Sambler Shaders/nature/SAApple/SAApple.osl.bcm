<?xml version="1.0" encoding="UTF-8"?>
<material view_color="rgb(0.80000, 0.80000, 0.80000)" sample_lamp="True">
	<nodes>
		<node type="OUTPUT_MATERIAL" loc="-252, 364" />
		<node type="SCRIPT" mode="INTERNAL" script="0" primarycolor="rgba(0.05000, 0.21999, 0.0, 1.0)" secondarycolor="rgba(0.25400, 0.23800, 0.0, 1.0)" glossy="0.02999" roughness="0.12999" dotdensity="35.84799" dotsize="0.20000" dotcenterfade="80.0" dotcenterintensity="0.60000" dotcentercolor="rgba(1.0, 0.88800, 0.46799, 1.0)" dotouterintensity="0.05000" dotouterfading="1.0" dotoutercolor="rgba(1.0, 1.0, 1.0, 1.0)" tipintensity="0.60000" smalldotcolor="rgba(0.54600, 0.49099, 0.25799, 1.0)" displacestrength="0.23000" loc="-568, 368" />
	</nodes>
	<links>
		<link to="0" input="0" from="1" output="0" />
		<link to="0" input="2" from="1" output="1" />
	</links>
	<scripts>
		<script name="SAApple.osl" id="0">
/*<br /> * SAApple.osl by Shane Ambler (c)2012<br /> * from https://github.com/sambler/osl-shaders<br /> *<br /> * license: BSD<br /> *<br /> * based on the cycles node tree by Rasmus Seerup at<br /> * http://materialw.wordpress.com/materials/apple-material/<br /> *<br /> */<br /><br />#include &quot;stdosl.h&quot;<br />#include &quot;node_texture.h&quot;<br /><br />float apple_noise(point p, string basis, float distortion, float detail)<br />{<br />	point r;<br /><br />	if (distortion != 0.0) {<br />		r[0] = noise_basis(p + point(13.5), basis) * distortion;<br />		r[1] = noise_basis(p, basis) * distortion;<br />		r[2] = noise_basis(p - point(13.5), basis) * distortion;<br />		<br />		p += r;<br />	}<br /><br />	return noise_turbulence(p, basis, detail, 0);<br />}<br /><br />float apple_voronoi (point p, float Scale)<br />{<br />    float da[4];<br />	point pa[4];<br />    <br />    voronoi(p * Scale, &quot;Distance Squared&quot;, 1.0, da, pa);<br /><br />	return fabs(da[0]);<br />}<br /><br />closure color closure_mix(closure color Closure1, closure color Closure2, float Fac)<br />{<br />	float t = clamp(Fac, 0.0, 1.0);<br />	return (1.0 - t) * Closure1 + t * Closure2;<br />}<br /><br />shader SAApple(<br />        color PrimaryColor = color(0.05, 0.22, 0.0),<br />        color SecondaryColor = color(0.254, 0.238, 0.0),<br />        float Glossy = 0.03,<br />        float Roughness = 0.13,<br />        float DotDensity = 35.848,<br />        float DotSize = 0.2,<br />        float DotCenterFade = 80.0,<br />        float DotCenterIntensity = 0.6,<br />        color DotCenterColor = color(1.0, 0.888, 0.468),<br />        float DotOuterIntensity = 0.05,<br />        float DotOuterFading = 1.0,<br />        color DotOuterColor = color(1.0),<br />        float TipIntensity = 0.6,<br />        color SmallDotColor = color(0.546, 0.491, 0.258),<br />        float DisplaceStrength = 0.23,<br />        output closure color BSDF = diffuse(N),<br />        output float Displacement = 0.0 )<br />{<br />    string Basis = &quot;Perlin&quot;;<br />    point mappingPoint = transform(&quot;object&quot;,P);<br />    color baseColor;<br />    float mixFactor;<br />    <br />    /* Base colour */<br />    mixFactor = apple_noise(mappingPoint * 1.4, Basis, 1.0, 2.0);<br />    baseColor = mix(PrimaryColor, SecondaryColor , mixFactor);<br /><br />    /* small dots */<br />    mixFactor = pow(apple_voronoi(P ,200.0), 0.05);<br />    baseColor = mix(SmallDotColor, baseColor, mixFactor);<br /><br />    /* big dots */<br />    mixFactor = (1.0-apple_voronoi(P, DotDensity));<br />    float mixModulator = mixFactor * floor(min(mixFactor + (DotSize - 0.5), 1.0) + 0.5);<br />    float centreFac = pow(mixModulator, DotCenterFade) * DotCenterIntensity;<br />    float backFac = pow(mixModulator, 1.0) * DotOuterIntensity;<br />    baseColor = mix(baseColor, DotOuterColor, backFac);<br />    baseColor = mix(baseColor, DotCenterColor, centreFac);<br /><br />    /* top and bottom shade */<br />    point nMap = transform(&quot;world&quot;,&quot;object&quot;,N);<br />    mixFactor = pow(max(nMap[2],0.0) + max(0.0 - nMap[2], 0.0),2.0) * TipIntensity;<br />    baseColor = mix(baseColor,mix(PrimaryColor,SmallDotColor,<br />                    apple_noise(mappingPoint * 5.0, Basis, 0.0, 2.0)), mixFactor);<br /><br />    /* add glossy */<br />    BSDF = closure_mix(baseColor * diffuse(N), microfacet_beckmann(N, Roughness), Glossy);<br />    Displacement = apple_noise(mappingPoint * 5.0, Basis, 0.0, 2.0) * DisplaceStrength;<br />}<br /><br /><br />
		</script>
	</scripts>
</material>