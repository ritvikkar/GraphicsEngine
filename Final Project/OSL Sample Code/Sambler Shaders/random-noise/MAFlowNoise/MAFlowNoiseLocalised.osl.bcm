<?xml version="1.0" encoding="UTF-8"?>
<material view_color="rgb(0.80000, 0.80000, 0.80000)" sample_lamp="True">
	<nodes>
		<node type="MIX_SHADER" fac="0.10000" width="150" loc="232, 299" />
		<node type="BUMP" strength="0.09999" width="150" loc="-267, 126" />
		<node type="VALTORGB" interpolation="CARDINAL" fac="0.5" stops="4" stop1="0.0|rgba(0.01038, 0.01226, 0.07597, 1.0)" stop2="0.12272|rgba(0.47487, 0.35618, 0.23020, 1.0)" stop3="0.37500|rgba(0.01819, 0.06213, 0.01672, 1.0)" stop4="0.68181|rgba(0.04433, 0.01086, 0.01517, 1.0)" width="240" loc="-318, 363" />
		<node type="REROUTE" width="16" loc="-356, 153" />
		<node type="BSDF_DIFFUSE" color="rgba(0.80000, 0.80000, 0.80000, 1.0)" roughness="0.0" width="150" loc="10, 300" />
		<node type="BSDF_GLOSSY" distribution="BECKMANN" color="rgba(0.80000, 0.80000, 0.80000, 1.0)" roughness="0.10000" width="150" loc="5, 162" />
		<node type="TEX_COORD" dupli="False" width="150" loc="-1166, 266" />
		<node type="REROUTE" width="16" loc="-942, 110" />
		<node type="MAPPING" translation="Vector(0.0, 0.0, 0.0)" rotation="Vector(0.0, 0.0, 0.0)" scale="Vector(8.0, 8.0, 8.0)" use_min="False" use_max="False" vector="Vector(0.0, 0.0, 0.0)" width="240" loc="-901, 353" />
		<node type="REROUTE" width="16" loc="-945, 32" />
		<node type="REROUTE" width="16" loc="-1432, 32" />
		<node type="VECT_MATH" operation="SUBTRACT" vector1="Vector(0.5, 0.5, 0.5)" vector2="Vector(1.0, -0.30000, 1.0)" width="80" loc="-1404, -5" />
		<node type="VECT_MATH" operation="DOT_PRODUCT" vector1="Vector(0.5, 0.5, 0.5)" vector2="Vector(0.5, 0.5, 0.5)" width="80" loc="-1296, -5" />
		<node type="MATH" operation="ADD" use_clamp="False" value1="0.5" value2="1.0" width="120" loc="-1189, -3" />
		<node type="MATH" operation="DIVIDE" use_clamp="False" value1="1.0" value2="1.0" width="120" loc="-1041, -3" />
		<node type="MATH" operation="POWER" use_clamp="False" value1="1.0" value2="4.25699" width="120" loc="-893, -3" />
		<node type="REROUTE" width="16" loc="-1430, -109" />
		<node type="MATH" operation="MULTIPLY" use_clamp="False" value1="1.0" value2="0.35800" width="120" loc="-745, -3" />
		<node type="OUTPUT_MATERIAL" width="120" loc="437, 300" />
		<node type="SCRIPT" mode="INTERNAL" script="0" vector="Vector(0.0, 0.0, 0.0)" dimensions="3" scale="1.70000" angle="0.0" octaves="5" h="0.22300" lacunarity="1.79999" advection="0.0" width="178" loc="-574, 343" />
	</nodes>
	<links>
		<link to="0" input="1" from="4" output="0" />
		<link to="2" input="0" from="3" output="0" />
		<link to="18" input="0" from="0" output="0" />
		<link to="0" input="2" from="5" output="0" />
		<link to="4" input="0" from="2" output="0" />
		<link to="1" input="1" from="3" output="0" />
		<link to="3" input="0" from="19" output="0" />
		<link to="8" input="0" from="7" output="0" />
		<link to="19" input="0" from="8" output="0" />
		<link to="5" input="2" from="1" output="0" />
		<link to="11" input="0" from="16" output="0" />
		<link to="12" input="0" from="11" output="0" />
		<link to="12" input="1" from="11" output="0" />
		<link to="13" input="0" from="12" output="1" />
		<link to="14" input="1" from="13" output="0" />
		<link to="15" input="0" from="14" output="0" />
		<link to="17" input="0" from="15" output="0" />
		<link to="10" input="0" from="9" output="0" />
		<link to="7" input="0" from="6" output="2" />
		<link to="9" input="0" from="7" output="0" />
		<link to="16" input="0" from="10" output="0" />
		<link to="19" input="7" from="17" output="0" />
	</links>
	<scripts>
		<script name="MAFlowNoise.osl" id="0">
/*<br /> * MAFlowNoise.osl by Michel J. Anders (c)2013<br /> * from https://github.com/sambler/osl-shaders<br /> *<br /> * license: public domain<br /> *<br /> * Simplex flow noise in 2 and 3D<br /> *<br /> * Based on Stefan Gustavsons orignal implementation in srdnoise23.c<br /> * (http://webstaff.itn.liu.se/~stegu/simplexnoise/DSOnoises.html)<br /> *<br /> * OSL port Michel Anders (varkenvarken) 2013-02-04<br /> * original comment is is left in place, OSL specific comments<br /> * are preceded by MJA<br /> *<br /> * This code was placed in the public domain by its original author,<br /> * Stefan Gustavson. You may use it as you see fit, but<br /> * attribution is appreciated.<br /> *<br /> */<br /><br />#include &quot;stdosl.h&quot;<br /><br />int FASTFLOOR(float x) {<br /> int xi = (int)x;<br /> return x &lt; xi ? xi-1 : xi;<br />}<br /><br />shader MAFlowNoise(<br />    vector Vector = P,<br />    int Dimensions = 2, /* 2 or 3 */<br />    float Scale = 1.0,<br />    float Angle = 0.0,<br />    int Octaves = 1,<br />    float H = 1.0,<br />    float Lacunarity = 2.0,<br />    float Advection = 0.0,<br />    output float Fac = 0.0 )<br />{<br /> int perm[512] = {151,160,137,91,90,15,<br /> 131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,8,99,37,240,21,10,23,<br /> 190, 6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,35,11,32,57,177,33,<br /> 88,237,149,56,87,174,20,125,136,171,168, 68,175,74,165,71,134,139,48,27,166,<br /> 77,146,158,231,83,111,229,122,60,211,133,230,220,105,92,41,55,46,245,40,244,<br /> 102,143,54, 65,25,63,161, 1,216,80,73,209,76,132,187,208, 89,18,169,200,196,<br /> 135,130,116,188,159,86,164,100,109,198,173,186, 3,64,52,217,226,250,124,123,<br /> 5,202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,189,28,42,<br /> 223,183,170,213,119,248,152, 2,44,154,163, 70,221,153,101,155,167, 43,172,9,<br /> 129,22,39,253, 19,98,108,110,79,113,224,232,178,185, 112,104,218,246,97,228,<br /> 251,34,242,193,238,210,144,12,191,179,162,241, 81,51,145,235,249,14,239,107,<br /> 49,192,214, 31,181,199,106,157,184, 84,204,176,115,121,50,45,127, 4,150,254,<br /> 138,236,205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180,<br /> 151,160,137,91,90,15,<br /> 131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,8,99,37,240,21,10,23,<br /> 190, 6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,35,11,32,57,177,33,<br /> 88,237,149,56,87,174,20,125,136,171,168, 68,175,74,165,71,134,139,48,27,166,<br /> 77,146,158,231,83,111,229,122,60,211,133,230,220,105,92,41,55,46,245,40,244,<br /> 102,143,54, 65,25,63,161, 1,216,80,73,209,76,132,187,208, 89,18,169,200,196,<br /> 135,130,116,188,159,86,164,100,109,198,173,186, 3,64,52,217,226,250,124,123,<br /> 5,202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,189,28,42,<br /> 223,183,170,213,119,248,152, 2,44,154,163, 70,221,153,101,155,167, 43,172,9,<br /> 129,22,39,253, 19,98,108,110,79,113,224,232,178,185, 112,104,218,246,97,228,<br /> 251,34,242,193,238,210,144,12,191,179,162,241, 81,51,145,235,249,14,239,107,<br /> 49,192,214, 31,181,199,106,157,184, 84,204,176,115,121,50,45,127, 4,150,254,<br /> 138,236,205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180};<br /> // MJA precomputing this table instead of calculating it as done in the <br /> // original code saves 30% running time.<br /> int permMod12[512] = { 7, 4, 5, 7, 6, 3, 11, 1, 9, 11, 0, 5, 2, 5, 7, 9, 8, <br /> 0, 7, 6, 9, 10, 8, 3, 1, 0, 9, 10, 11, 10, 6, 4, 7, 0, 6, 3, 0, 2, 5, 2, 10, <br /> 0, 3, 11, 9, 11, 11, 8, 9, 9, 9, 4, 9, 5, 8, 3, 6, 8, 5, 4, 3, 0, 8, 7, 2, 9, <br /> 11, 2, 7, 0, 3, 10, 5, 2, 2, 3, 11, 3, 1, 2, 0, 7, 1, 2, 4, 9, 8, 5, 7, 10, <br /> 5, 4, 4, 6, 11, 6, 5, 1, 3, 5, 1, 0, 8, 1, 5, 4, 0, 7, 4, 5, 6, 1, 8, 4, 3, <br /> 10, 8, 8, 3, 2, 8, 4, 1, 6, 5, 6, 3, 4, 4, 1, 10, 10, 4, 3, 5, 10, 2, 3, 10, <br /> 6, 3, 10, 1, 8, 3, 2, 11, 11, 11, 4, 10, 5, 2, 9, 4, 6, 7, 3, 2, 9, 11, 8, 8, <br /> 2, 8, 10, 7, 10, 5, 9, 5, 11, 11, 7, 4, 9, 9, 10, 3, 1, 7, 2, 0, 2, 7, 5, 8, <br /> 4, 10, 5, 4, 8, 2, 6, 1, 0, 11, 10, 2, 1, 10, 6, 0, 0, 11, 11, 6, 1, 9, 3, 1, <br /> 7, 9, 2, 11, 11, 1, 0, 10, 7, 1, 7, 10, 1, 4, 0, 0, 8, 7, 1, 2, 9, 7, 4, 6, 2, <br /> 6, 8, 1, 9, 6, 6, 7, 5, 0, 0, 3, 9, 8, 3, 6, 6, 11, 1, 0, 0, 7, 4, 5, 7, 6, 3, <br /> 11, 1, 9, 11, 0, 5, 2, 5, 7, 9, 8, 0, 7, 6, 9, 10, 8, 3, 1, 0, 9, 10, 11, 10, <br /> 6, 4, 7, 0, 6, 3, 0, 2, 5, 2, 10, 0, 3, 11, 9, 11, 11, 8, 9, 9, 9, 4, 9, 5, 8, <br /> 3, 6, 8, 5, 4, 3, 0, 8, 7, 2, 9, 11, 2, 7, 0, 3, 10, 5, 2, 2, 3, 11, 3, 1, 2, <br /> 0, 7, 1, 2, 4, 9, 8, 5, 7, 10, 5, 4, 4, 6, 11, 6, 5, 1, 3, 5, 1, 0, 8, 1, 5, 4, <br /> 0, 7, 4, 5, 6, 1, 8, 4, 3, 10, 8, 8, 3, 2, 8, 4, 1, 6, 5, 6, 3, 4, 4, 1, 10, 10, <br /> 4, 3, 5, 10, 2, 3, 10, 6, 3, 10, 1, 8, 3, 2, 11, 11, 11, 4, 10, 5, 2, 9, 4, 6, 7, <br /> 3, 2, 9, 11, 8, 8, 2, 8, 10, 7, 10, 5, 9, 5, 11, 11, 7, 4, 9, 9, 10, 3, 1, 7, 2, <br /> 0, 2, 7, 5, 8, 4, 10, 5, 4, 8, 2, 6, 1, 0, 11, 10, 2, 1, 10, 6, 0, 0, 11, 11, 6, <br /> 1, 9, 3, 1, 7, 9, 2, 11, 11, 1, 0, 10, 7, 1, 7, 10, 1, 4, 0, 0, 8, 7, 1, 2, 9, 7, <br /> 4, 6, 2, 6, 8, 1, 9, 6, 6, 7, 5, 0, 0, 3, 9, 8, 3, 6, 6, 11, 1, 0, 0};<br /> <br /> /*<br />  * Gradient tables. These could be programmed the Ken Perlin way with<br />  * some clever bit-twiddling, but this is more clear, and not really slower.<br />  */<br /> vector grad2[8] = {<br />   vector( -1.0, -1.0 , 0.0), vector( 1.0, 0.0 , 0.0) , vector( -1.0, 0.0 , 0.0) , vector( 1.0, 1.0 , 0.0) ,<br />   vector( -1.0, 1.0 , 0.0) , vector( 0.0, -1.0 , 0.0) , vector( 0.0, 1.0 , 0.0) , vector( 1.0, -1.0 , 0.0)<br /> };<br /><br /> /*<br />  * For 3D, we define two orthogonal vectors in the desired rotation plane.<br />  * These vectors are based on the midpoints of the 12 edges of a cube,<br />  * they all rotate in their own plane and are never coincident or collinear.<br />  * A larger array of random vectors would also do the job, but these 12<br />  * (including 4 repeats to make the array length a power of two) work better.<br />  * They are not random, they are carefully chosen to represent a small<br />  * isotropic set of directions for any rotation angle.<br />  */<br /><br /> /* a = sqrt(2)/sqrt(3) = 0.816496580 */<br />#define a 0.81649658<br /><br /> vector grad3u[16] = {<br />   vector( 1.0, 0.0, 1.0 ), vector( 0.0, 1.0, 1.0 ), // 12 cube edges<br />   vector( -1.0, 0.0, 1.0 ), vector( 0.0, -1.0, 1.0 ),<br />   vector( 1.0, 0.0, -1.0 ), vector( 0.0, 1.0, -1.0 ),<br />   vector( -1.0, 0.0, -1.0 ), vector( 0.0, -1.0, -1.0 ),<br />   vector( a, a, a ), vector( -a, a, -a ),<br />   vector( -a, -a, a ), vector( a, -a, -a ),<br />   vector( -a, a, a ), vector( a, -a, a ),<br />   vector( a, -a, -a ), vector( -a, a, -a )<br /> };<br /><br /> vector grad3v[16] = {<br />   vector( -a, a, a ), vector( -a, -a, a ),<br />   vector( a, -a, a ), vector( a, a, a ),<br />   vector( -a, -a, -a ), vector( a, -a, -a ),<br />   vector( a, a, -a ), vector( -a, a, -a ),<br />   vector( 1.0, -1.0, 0.0 ), vector( 1.0, 1.0, 0.0 ),<br />   vector( -1.0, 1.0, 0.0 ), vector( -1.0, -1.0, 0.0 ),<br />   vector( 1.0, 0.0, 1.0 ), vector( -1.0, 0.0, 1.0 ), // 4 repeats to make 16<br />   vector( 0.0, 1.0, -1.0 ), vector( 0.0, -1.0, -1.0 )<br /> };<br /><br />#undef a<br /><br /> /*<br />  * Helper functions to compute rotated gradients and<br />  * gradients-dot-residualvectors in 2D and 3D.<br />  */<br /><br /> void gradrot2( int hash, float sin_t, float cos_t, float gx, float gy ) {<br />  int h = hash &amp; 7;<br />  float gx0 = grad2[h][0];<br />  float gy0 = grad2[h][1];<br />  gx = cos_t * gx0 - sin_t * gy0;<br />  gy = sin_t * gx0 + cos_t * gy0;<br />  return;<br /> }<br /><br /> void gradrot3( int hash, float sin_t, float cos_t, float gx, float gy, float gz ) {<br />  int h = hash &amp; 15;<br />  float gux = grad3u[h][0];<br />  float guy = grad3u[h][1];<br />  float guz = grad3u[h][2];<br />  float gvx = grad3v[h][0];<br />  float gvy = grad3v[h][1];<br />  float gvz = grad3v[h][2];<br />  gx = cos_t * gux + sin_t * gvx;<br />  gy = cos_t * guy + sin_t * gvy;<br />  gz = cos_t * guz + sin_t * gvz;<br />  return;<br /> }<br /><br /> float graddotp3( float gx, float gy, float gz, float x, float y, float z ) {<br />  return gx * x + gy * y + gz * z;<br /> }<br /><br /> float angle = Angle; // MJA copy input parameter so that we can write it<br /><br /> float pwr = 1.0;<br /> float pwHL = pow(Lacunarity,-H);<br /> <br /> /* Skewing factors for 2D simplex grid:<br />  * F2 = 0.5*(sqrt(3.0)-1.0)<br />  * G2 = (3.0-Math.sqrt(3.0))/6.0<br />  */<br />#define F2 0.366025403<br />#define G2 0.211324865<br /><br /> /** 2D simplex noise with derivatives.<br />  * If the last two arguments are not null, the analytic derivative<br />  * (the 2D gradient of the scalar noise field) is also calculated.<br />  */<br /> if( Dimensions &lt;= 2 ){<br />  float x = Vector[0]*Scale;<br />  float y = Vector[1]*Scale;<br />  float dnoise_dx;<br />  float dnoise_dy;<br />  float sin_t, cos_t; /* Sine and cosine for the gradient rotation angle */<br />  sin_t = sin( angle );<br />  cos_t = cos( angle );<br />  for(int p=0; p &lt; Octaves; p++){<br />   float n0, n1, n2; /* Noise contributions from the three simplex corners */<br />   float gx0, gy0, gx1, gy1, gx2, gy2; /* Gradients at simplex corners */<br /><br />   /* Skew the input space to determine which simplex cell we're in */<br />   float s = ( x + y ) * F2; /* Hairy factor for 2D */<br />   float xs = x + s;<br />   float ys = y + s;<br />   int i = FASTFLOOR( xs );<br />   int j = FASTFLOOR( ys );<br /><br />   float t = ( i + j ) * G2;<br />   float X0 = i - t; /* Unskew the cell origin back to (x,y) space */<br />   float Y0 = j - t;<br />   float x0 = x - X0; /* The x,y distances from the cell origin */<br />   float y0 = y - Y0;<br /><br />   /* For the 2D case, the simplex shape is an equilateral triangle.<br />    * Determine which simplex we are in. */<br />   int i1, j1; /* Offsets for second (middle) corner of simplex in (i,j) coords */<br />   if( x0 &gt; y0 ) { i1 = 1; j1 = 0; } /* lower triangle, XY order: (0,0)-&gt;(1,0)-&gt;(1,1) */<br />   else { i1 = 0; j1 = 1; }      /* upper triangle, YX order: (0,0)-&gt;(0,1)-&gt;(1,1) */<br /><br />   /* A step of (1,0) in (i,j) means a step of (1-c,-c) in (x,y), and<br />    * a step of (0,1) in (i,j) means a step of (-c,1-c) in (x,y), where<br />    * c = (3-sqrt(3))/6   */<br />   float x1 = x0 - i1 + G2; /* Offsets for middle corner in (x,y) unskewed coords */<br />   float y1 = y0 - j1 + G2;<br />   float x2 = x0 - 1.0 + 2.0 * G2; /* Offsets for last corner in (x,y) unskewed coords */<br />   float y2 = y0 - 1.0 + 2.0 * G2;<br /><br />   /* Wrap the integer indices at 256, to avoid indexing perm[] out of bounds */<br />   int ii = i &amp; 255; // MJA was % 256 but OSL mod is not the same as C %<br />   int jj = j &amp; 255;<br /><br />   /* Calculate the contribution from the three corners */<br />   float t0 = 0.5 - x0 * x0 - y0 * y0;<br />   float t20, t40;<br />   if( t0 &lt; 0.0 ) t40 = t20 = t0 = n0 = gx0 = gy0 = 0.0; /* No influence */<br />   else {<br />     gradrot2( perm[ii + perm[jj]], sin_t, cos_t, gx0, gy0 );<br />     t20 = t0 * t0;<br />     t40 = t20 * t20;<br />     n0 = t40 * ( gx0 * x0 + gy0 * y0 );<br />   }<br /><br />   float t1 = 0.5 - x1 * x1 - y1 * y1;<br />   float t21, t41;<br />   if( t1 &lt; 0.0 ) t21 = t41 = t1 = n1 = gx1 = gy1 = 0.0; /* No influence */<br />   else {<br />     gradrot2( perm[ii + i1 + perm[jj + j1]], sin_t, cos_t, gx1, gy1 );<br />     t21 = t1 * t1;<br />     t41 = t21 * t21;<br />     n1 = t41 * ( gx1 * x1 + gy1 * y1 );<br />   }<br /><br />   float t2 = 0.5 - x2 * x2 - y2 * y2;<br />   float t22, t42;<br />   if( t2 &lt; 0.0 ) t42 = t22 = t2 = n2 = gx2 = gy2 = 0.0; /* No influence */<br />   else {<br />     gradrot2( perm[ii + 1 + perm[jj + 1]], sin_t, cos_t, gx2, gy2 );<br />     t22 = t2 * t2;<br />     t42 = t22 * t22;<br />     n2 = t42 * ( gx2 * x2 + gy2 * y2 );<br />   }<br /><br />   /* Add contributions from each corner to get the final noise value.<br />    * The result is scaled to return values in the interval [-1,1]. */<br />   float noise = 70.0 * ( n0 + n1 + n2 ); // MJA scale factor was 40<br /><br />   /* Compute derivative, if requested by supplying non-null pointers<br />    * for the last two arguments */<br />   if( Advection != 0 ){<br />   /*  A straight, unoptimised calculation would be like:<br />    *    *dnoise_dx = -8.0 * t20 * t0 * x0 * ( gx0 * x0 + gy0 * y0 ) + t40 * gx0;<br />    *    *dnoise_dy = -8.0 * t20 * t0 * y0 * ( gx0 * x0 + gy0 * y0 ) + t40 * gy0;<br />    *    *dnoise_dx += -8.0 * t21 * t1 * x1 * ( gx1 * x1 + gy1 * y1 ) + t41 * gx1;<br />    *    *dnoise_dy += -8.0 * t21 * t1 * y1 * ( gx1 * x1 + gy1 * y1 ) + t41 * gy1;<br />    *    *dnoise_dx += -8.0 * t22 * t2 * x2 * ( gx2 * x2 + gy2 * y2 ) + t42 * gx2;<br />    *    *dnoise_dy += -8.0 * t22 * t2 * y2 * ( gx2 * x2 + gy2 * y2 ) + t42 * gy2;<br />    */<br />    float temp0 = t20 * t0 * ( gx0* x0 + gy0 * y0 );<br />    dnoise_dx = temp0 * x0;<br />    dnoise_dy = temp0 * y0;<br />    float temp1 = t21 * t1 * ( gx1 * x1 + gy1 * y1 );<br />    dnoise_dx += temp1 * x1;<br />    dnoise_dy += temp1 * y1;<br />    float temp2 = t22 * t2 * ( gx2* x2 + gy2 * y2 );<br />    dnoise_dx += temp2 * x2;<br />    dnoise_dy += temp2 * y2;<br />    dnoise_dx *= -8.0;<br />    dnoise_dy *= -8.0;<br />    dnoise_dx += t40 * gx0 + t41 * gx1 + t42 * gx2;<br />    dnoise_dy += t40 * gy0 + t41 * gy1 + t42 * gy2;<br />    dnoise_dx *= 70.0; /* Scale derivative to match the noise scaling */ // MJA scale factor was 40<br />    dnoise_dy *= 70.0;<br />    <br />    float advect_x = -Advection * dnoise_dx;<br />    float advect_y = -Advection * dnoise_dy;<br />    Fac += noise * pwr;<br /><br />    pwr *= pwHL;<br />    x *= Lacunarity;<br />    y *= Lacunarity;<br /><br />    x += advect_x*pow(Lacunarity,p);<br />    y += advect_y*pow(Lacunarity,p);<br />    angle *= Lacunarity;<br />   }else{<br />    Fac += noise * pwr;<br />    pwr *= pwHL;<br />    x *= Lacunarity;<br />    y *= Lacunarity;<br />   }<br />  }<br /> }else if(Dimensions&gt;=3){<br /> /* Skewing factors for 3D simplex grid:<br />  * F3 = 1/3<br />  * G3 = 1/6 */<br />#define F3 0.333333333<br />#define G3 0.166666667<br /><br />  float x=Vector[0]*Scale;<br />  float y=Vector[1]*Scale;<br />  float z=Vector[2]*Scale;<br />        float dnoise_dx;<br />  float dnoise_dy;<br />  float dnoise_dz;<br /><br />  float n0, n1, n2, n3; /* Noise contributions from the four simplex corners */<br />  float noise;          /* Return value */<br />  float gx0, gy0, gz0, gx1, gy1, gz1; /* Gradients at simplex corners */<br />  float gx2, gy2, gz2, gx3, gy3, gz3;<br />  float sin_t, cos_t; /* Sine and cosine for the gradient rotation angle */<br />  sin_t = sin( angle );<br />  cos_t = cos( angle );<br />  for(int p=0; p &lt; Octaves; p++){<br />   /* Skew the input space to determine which simplex cell we're in */<br />   float s = (x+y+z)*F3; /* Very nice and simple skew factor for 3D */<br />   float xs = x+s;<br />   float ys = y+s;<br />   float zs = z+s;<br />   int i = FASTFLOOR(xs);<br />   int j = FASTFLOOR(ys);<br />   int k = FASTFLOOR(zs);<br /><br />   float t = (float)(i+j+k)*G3; <br />   float X0 = i-t; /* Unskew the cell origin back to (x,y,z) space */<br />   float Y0 = j-t;<br />   float Z0 = k-t;<br />   float x0 = x-X0; /* The x,y,z distances from the cell origin */<br />   float y0 = y-Y0;<br />   float z0 = z-Z0;<br /><br />   /* For the 3D case, the simplex shape is a slightly irregular tetrahedron.<br />    * Determine which simplex we are in. */<br />   int i1, j1, k1; /* Offsets for second corner of simplex in (i,j,k) coords */<br />   int i2, j2, k2; /* Offsets for third corner of simplex in (i,j,k) coords */<br /><br />   /* TODO: This code would benefit from a backport from the GLSL version! */<br />   if(x0&gt;=y0) {<br />     if(y0&gt;=z0)<br />    { i1=1; j1=0; k1=0; i2=1; j2=1; k2=0; } /* X Y Z order */<br />    else if(x0&gt;=z0) { i1=1; j1=0; k1=0; i2=1; j2=0; k2=1; } /* X Z Y order */<br />    else { i1=0; j1=0; k1=1; i2=1; j2=0; k2=1; } /* Z X Y order */<br />     }<br />   else { // x0 &lt; y0<br />     if(y0 &lt; z0) { i1=0; j1=0; k1=1; i2=0; j2=1; k2=1; } /* Z Y X order */<br />     else if(x0 &lt; z0) { i1=0; j1=1; k1=0; i2=0; j2=1; k2=1; } /* Y Z X order */<br />     else { i1=0; j1=1; k1=0; i2=1; j2=1; k2=0; } /* Y X Z order */<br />   }<br /><br />   /* A step of (1,0,0) in (i,j,k) means a step of (1-c,-c,-c) in (x,y,z),<br />    * a step of (0,1,0) in (i,j,k) means a step of (-c,1-c,-c) in (x,y,z), and<br />    * a step of (0,0,1) in (i,j,k) means a step of (-c,-c,1-c) in (x,y,z), where<br />    * c = 1/6.   */<br /><br />   float x1 = x0 - i1 + G3; /* Offsets for second corner in (x,y,z) coords */<br />   float y1 = y0 - j1 + G3;<br />   float z1 = z0 - k1 + G3;<br />   float x2 = x0 - i2 + 2.0 * G3; /* Offsets for third corner in (x,y,z) coords */<br />   float y2 = y0 - j2 + 2.0 * G3;<br />   float z2 = z0 - k2 + 2.0 * G3;<br />   float x3 = x0 - 1.0 + 3.0 * G3; /* Offsets for last corner in (x,y,z) coords */<br />   float y3 = y0 - 1.0 + 3.0 * G3;<br />   float z3 = z0 - 1.0 + 3.0 * G3;<br /><br />   /* Wrap the integer indices at 256, to avoid indexing perm[] out of bounds */<br />   int ii = i &amp; 255; // MJA was % 256 but OSL mod is not the same as C %<br />   int jj = j &amp; 255;<br />   int kk = k &amp; 255;<br /><br />   /* Calculate the contribution from the four corners */<br />   float t0 = 0.6 - x0*x0 - y0*y0 - z0*z0;<br />   float t20, t40;<br />   if(t0 &lt; 0.0) n0 = t0 = t20 = t40 = gx0 = gy0 = gz0 = 0.0;<br />   else {<br />     gradrot3( perm[ii + perm[jj + perm[kk]]], sin_t, cos_t, gx0, gy0, gz0 );<br />     t20 = t0 * t0;<br />     t40 = t20 * t20;<br />     n0 = t40 * graddotp3( gx0, gy0, gz0, x0, y0, z0 );<br />   }<br /><br />   float t1 = 0.6 - x1*x1 - y1*y1 - z1*z1;<br />   float t21, t41;<br />   if(t1 &lt; 0.0) n1 = t1 = t21 = t41 = gx1 = gy1 = gz1 = 0.0;<br />   else {<br />     gradrot3( perm[ii + i1 + perm[jj + j1 + perm[kk + k1]]], sin_t, cos_t, gx1, gy1, gz1 );<br />     t21 = t1 * t1;<br />     t41 = t21 * t21;<br />     n1 = t41 * graddotp3( gx1, gy1, gz1, x1, y1, z1 );<br />   }<br /><br />   float t2 = 0.6 - x2*x2 - y2*y2 - z2*z2;<br />   float t22, t42;<br />   if(t2 &lt; 0.0) n2 = t2 = t22 = t42 = gx2 = gy2 = gz2 = 0.0;<br />   else {<br />     gradrot3( perm[ii + i2 + perm[jj + j2 + perm[kk + k2]]], sin_t, cos_t, gx2, gy2, gz2 );<br />     t22 = t2 * t2;<br />     t42 = t22 * t22;<br />     n2 = t42 * graddotp3( gx2, gy2, gz2, x2, y2, z2 );<br />   }<br /><br />   float t3 = 0.6 - x3*x3 - y3*y3 - z3*z3;<br />   float t23, t43;<br />   if(t3 &lt; 0.0) n3 = t3 = t23 = t43 = gx3 = gy3 = gz3 = 0.0;<br />   else {<br />     gradrot3( perm[ii + 1 + perm[jj + 1 + perm[kk + 1]]], sin_t, cos_t, gx3, gy3, gz3 );<br />     t23 = t3 * t3;<br />     t43 = t23 * t23;<br />     n3 = t43 * graddotp3( gx3, gy3, gz3, x3, y3, z3 );<br />   }<br /><br />   /*  Add contributions from each corner to get the final noise value.<br />    * The result is scaled to return values in the range [-1,1] */<br />   noise = 28.0 * (n0 + n1 + n2 + n3);<br /><br />   /* Compute derivative, if requested by supplying non-null pointers<br />    * for the last three arguments */<br />   if(Advection != 0){<br />   /*  A straight, unoptimised calculation would be like:<br />    *     *dnoise_dx = -8.0f * t20 * t0 * x0 * graddotp3(gx0, gy0, gz0, x0, y0, z0) + t40 * gx0;<br />    *    *dnoise_dy = -8.0f * t20 * t0 * y0 * graddotp3(gx0, gy0, gz0, x0, y0, z0) + t40 * gy0;<br />    *    *dnoise_dz = -8.0f * t20 * t0 * z0 * graddotp3(gx0, gy0, gz0, x0, y0, z0) + t40 * gz0;<br />    *    *dnoise_dx += -8.0f * t21 * t1 * x1 * graddotp3(gx1, gy1, gz1, x1, y1, z1) + t41 * gx1;<br />    *    *dnoise_dy += -8.0f * t21 * t1 * y1 * graddotp3(gx1, gy1, gz1, x1, y1, z1) + t41 * gy1;<br />    *    *dnoise_dz += -8.0f * t21 * t1 * z1 * graddotp3(gx1, gy1, gz1, x1, y1, z1) + t41 * gz1;<br />    *    *dnoise_dx += -8.0f * t22 * t2 * x2 * graddotp3(gx2, gy2, gz2, x2, y2, z2) + t42 * gx2;<br />    *    *dnoise_dy += -8.0f * t22 * t2 * y2 * graddotp3(gx2, gy2, gz2, x2, y2, z2) + t42 * gy2;<br />    *    *dnoise_dz += -8.0f * t22 * t2 * z2 * graddotp3(gx2, gy2, gz2, x2, y2, z2) + t42 * gz2;<br />    *    *dnoise_dx += -8.0f * t23 * t3 * x3 * graddotp3(gx3, gy3, gz3, x3, y3, z3) + t43 * gx3;<br />    *    *dnoise_dy += -8.0f * t23 * t3 * y3 * graddotp3(gx3, gy3, gz3, x3, y3, z3) + t43 * gy3;<br />    *    *dnoise_dz += -8.0f * t23 * t3 * z3 * graddotp3(gx3, gy3, gz3, x3, y3, z3) + t43 * gz3;<br />    */<br />    float temp0 = t20 * t0 * graddotp3( gx0, gy0, gz0, x0, y0, z0 );<br />    dnoise_dx = temp0 * x0;<br />    dnoise_dy = temp0 * y0;<br />    dnoise_dz = temp0 * z0;<br />    float temp1 = t21 * t1 * graddotp3( gx1, gy1, gz1, x1, y1, z1 );<br />    dnoise_dx += temp1 * x1;<br />    dnoise_dy += temp1 * y1;<br />    dnoise_dz += temp1 * z1;<br />    float temp2 = t22 * t2 * graddotp3( gx2, gy2, gz2, x2, y2, z2 );<br />    dnoise_dx += temp2 * x2;<br />    dnoise_dy += temp2 * y2;<br />    dnoise_dz += temp2 * z2;<br />    float temp3 = t23 * t3 * graddotp3( gx3, gy3, gz3, x3, y3, z3 );<br />    dnoise_dx += temp3 * x3;<br />    dnoise_dy += temp3 * y3;<br />    dnoise_dz += temp3 * z3;<br />    dnoise_dx *= -8.0;<br />    dnoise_dy *= -8.0;<br />    dnoise_dz *= -8.0;<br />    /* This corrects a bug in the original implementation */<br />    dnoise_dx += t40 * gx0 + t41 * gx1 + t42 * gx2 + t43 * gx3;<br />    dnoise_dy += t40 * gy0 + t41 * gy1 + t42 * gy2 + t43 * gy3;<br />    dnoise_dz += t40 * gz0 + t41 * gz1 + t42 * gz2 + t43 * gz3;<br />    dnoise_dx *= 28.0; /* Scale derivative to match the noise scaling */<br />    dnoise_dy *= 28.0;<br />    dnoise_dz *= 28.0;<br /><br />    float advect_x = -Advection * dnoise_dx;<br />    float advect_y = -Advection * dnoise_dy;<br />    float advect_z = -Advection * dnoise_dz;<br />    Fac += noise * pwr;<br /><br />    pwr *= pwHL;<br />    x *= Lacunarity;<br />    y *= Lacunarity;<br /><br />    x += advect_x*pow(Lacunarity,p);<br />    y += advect_y*pow(Lacunarity,p);<br />    y += advect_z*pow(Lacunarity,p);<br />    angle *= Lacunarity;<br />   }else{<br />    Fac += noise * pwr;<br />    pwr *= pwHL;<br />    x *= Lacunarity;<br />    y *= Lacunarity;<br />    z *= Lacunarity;<br />   }<br />  }<br /> }<br />}<br /><br />
		</script>
	</scripts>
</material>
