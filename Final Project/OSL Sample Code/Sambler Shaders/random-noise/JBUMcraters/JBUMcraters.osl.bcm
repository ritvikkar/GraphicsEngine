<?xml version="1.0" encoding="UTF-8"?>
<material view_color="rgb(0.80000, 0.80000, 0.80000)" sample_lamp="True">
	<nodes>
		<node type="TEX_COORD" dupli="False" width="150" loc="-731, 148" />
		<node type="MAPPING" translation="Vector(0.0, 0.0, 0.0)" rotation="Vector(0.0, 0.0, 0.0)" scale="Vector(1.0, 1.0, 1.0)" use_min="False" use_max="False" vector="Vector(0.0, 0.0, 0.0)" width="240" loc="-538, 241" />
		<node type="BSDF_GLOSSY" distribution="BECKMANN" color="rgba(0.24483, 0.31834, 0.56948, 1.0)" roughness="0.10000" width="150" loc="-76, 247" />
		<node type="OUTPUT_MATERIAL" width="120" loc="123, 240" />
		<node type="SCRIPT" mode="INTERNAL" script="0" vector="Vector(0.0, 0.0, 0.0)" maxdepth="0.5" maxwidth="0.20000" probability="0.69999" detail="10.0" spacing="2.0" amplitude="2.0" jitter="1.0" width="140" loc="-262, 262" />
	</nodes>
	<links>
		<link to="1" input="0" from="0" output="2" />
		<link to="4" input="0" from="1" output="0" />
		<link to="3" input="0" from="2" output="0" />
		<link to="2" input="2" from="4" output="0" />
	</links>
	<scripts>
		<script name="JBUMcraters.osl" id="0">
/*******************************************************************************<br /> * JBUMcraters.sl -- Lunar-like surface - Jim Bumgardner jbum@jbum.com<br /> *<br /> * Voronoi/Worley noise is combined using 1/f scaling to put craters on a surface.<br /> * Similar tricks can be used to make cork, swiss-cheese, bread, etc.<br /> ******************************************************************************/<br /><br />#include &quot;noises_osl.h&quot;<br /><br />shader JBUMcraters (<br />    vector Vector = P,<br />    //float roughness = 0.1,<br />    float MaxDepth = 0.6,    /* Depth of crater displacement */<br />    float MaxWidth= 0.3,      /* Size of largest crater relative to s/t mapping */<br />    float Probability = 0.7, /* chance of crater occuring in a cell */<br />    float Detail = 9.0,      /* number of scales used - use lower numbers for cartoony effects */<br />    float Spacing = 2.0,    /* diameter spacing between successive Detail */<br />    float Amplitude = 2.0,    /* amplitude reduction between successive Detail */<br />    float Jitter = 1.0,     /* irregularity of crater spacing */<br /><br />   /* you'll get artifacts if you go too much higher than 1 */<br />   /* but this can be avoided by looping i,j from -2 to 2 instead of -1 to 1 */<br />   //float Distortion = 0.0005, /* Crater distortion.  You'll get artifacts if it goes too high. */<br /><br />   output normal Normal = 0<br />)<br />{<br /><br />    vector faceforward(vector N, vector I)<br />    {<br />        return (dot(I,Ng) &gt; 0) ? -N : N;<br />    }<br /><br />    float s = Vector[0];<br />    float t = Vector[1];<br /><br />    normal Nf;<br /><br />    float ss, tt, angle, r, rim, uu, a, i, j, sc, asc, lev;<br />    float sctr, tctr, scell, tcell,scellctr,tcellctr;<br />    float pert=0,rad,pert2;<br />    float rmax = MaxWidth/2; /* was /2 */<br />    float    rmax1=1000000,rmax2=1000000,rrad1=0,rrad2=0,cellsizescale,ilac;<br /><br />    ilac = 1/Spacing;<br /><br />    /* Add craters */<br /><br />    for (lev = 0; lev &lt; Detail; lev += 1)<br />      {<br />    sc = pow(Spacing, lev);<br />    asc = 1 / pow(Amplitude, lev);<br />    scellctr = floor(s*sc/MaxWidth);<br />    tcellctr = floor(t*sc/MaxWidth);<br />    cellsizescale = MaxWidth/sc;<br />    rrad1 = 0;<br />    rrad2 = 0;<br />    for (i = -1; i &lt;= 1; i += 1)<br />      {<br />        scell = scellctr + i;<br />        for (j = -1; j &lt;= 1; j += 1)<br />          {<br />        tcell = tcellctr + j;<br />        if ( cellnoise(7*scell-9.5, 7*tcell+7.5) &lt; Probability)<br />          /* xp = (sc*7*scell-9.5,sc*7*tcell+7.5,.5); */<br />          /* if ( fBm_default(xp) &lt; Probability)  *//* I like this distribution better - pitf = -1 -&gt; 1 */<br />          {<br />            sctr = cellsizescale * (scell + 0.5 + Jitter * cellnoise(scell+0.5, tcell+0.5));<br />            tctr = cellsizescale * (tcell + 0.5 + Jitter * cellnoise(scell+3.5, tcell+8.5));<br />            ss = s - sctr;<br />            tt = t - tctr;<br />            r = ss*ss + tt*tt; /* r is distance from center squared */<br />            if (r &lt; rmax1) {<br />              /* rad is size of crater squared */<br />              rad = rmax*ilac;<br />              rad /= sc;<br />              rad *= rad;<br />              rmax2 = rmax1;<br />              rrad2 = rrad1;<br />              rmax1 = r;<br />              rrad1 = rad;<br />            }<br />            else if (r &lt; rmax2) {<br />              /* rad is size of crater squared */<br />              rad = rmax*ilac;<br />              rad /= sc;<br />              rad *= rad;<br />              rmax2 = r;<br />              rrad2 = rad;<br />            }<br />          }<br />          }<br />      }<br />    /* Optional Crater Distortion... */<br />    //if (Distortion != 0)<br />    //  {<br />        // rrad1 += fBm_default(P*sc)*asc*Distortion; /* add crater roughness */<br />        // rrad2 += fBm_default(P*sc)*asc*Distortion;<br />    //  }<br /><br />    /* Seem crater perturbations for each scale */<br />    if (rrad1 &gt; 0 &amp;&amp; rmax1 &gt; 0)<br />      {<br />        r = smoothstep(0,rrad1,rmax1);<br />        r = r*(2*r-pow(r,3))+(1-r)*pow(r,3);<br />        pert += sin(r*M_PI/2)*asc-asc;<br />      }<br />    if (rrad2 &gt; 0 &amp;&amp; rmax2 &gt; 0)<br />      {<br />        r = smoothstep(0,rrad2,rmax2);<br />        r = r*(2*r-pow(r,3))+(1-r)*pow(r,3);<br />        pert += sin(r*M_PI/2)*asc-asc;<br />      }<br />      }<br /><br />    P += MaxDepth*pert*normalize(N);<br />    N = calculatenormal(P);<br />    Nf = faceforward (normalize(N),-I);<br />    Normal = Nf;<br />}<br /><br />
		</script>
	</scripts>
</material>