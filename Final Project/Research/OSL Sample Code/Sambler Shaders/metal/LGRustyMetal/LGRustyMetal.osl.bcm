<?xml version="1.0" encoding="UTF-8"?>
<material view_color="rgb(0.80000, 0.80000, 0.80000)" sample_lamp="True">
	<nodes>
		<node type="TEX_COORD" dupli="False" loc="-178, 284" />
		<node type="OUTPUT_MATERIAL" loc="293, 309" />
		<node type="SCRIPT" mode="INTERNAL" script="0" vector="Vector(0.0, 0.0, 0.0)" diffuse="0.99999" roughness="0.10000" scale="11.89999" rustamt="0.69999" rustcolor="rgba(0.28968, 0.06151, 0.02470, 1.0)" rustdiffuse="0.69999" rustbump="0.43500" loc="52, 316" />
	</nodes>
	<links>
		<link to="2" input="0" from="0" output="2" />
		<link to="1" input="0" from="2" output="0" />
	</links>
	<scripts>
		<script name="LGRustyMetal.osl" id="0">
/*<br /> * LGRustyMetal.osl by Charlie (c)2012<br /> * from https://github.com/sambler/osl-shaders<br /> *<br /> * rustymetal.sl -- metal with specks of rust<br /> *<br /> *  {converted/hacked to OSL from http://www.renderman.org/RMR/Shaders/LGShaders/LGRustyMetal.sl}<br /> *<br /> * DESCRIPTION:<br /> *   A rough metal surface with controllable rust spots.  The rust pattern<br /> *   is basically thresholded turbulence (summed abs(snoise)).  Where it's<br /> *   RustAmt, shade like rust colored matte, and also make it bumpy (like<br /> *   the corrosion is kind of grainy).  Where there is no rust, shade like<br /> *   regular metal.  All computations are done in shader space.<br /> *<br /> * PARAMETERS<br /> *   metalKa, Diffuse, Roughness - control the appearance of the metal.<br /> *   rustKa, RustDiffuse, RustColor - control the appearance of the rust.<br /> *   Scale - overall scaling factor of the rust pattern.<br /> *   RustAmt - 0=no rust, larger for more rust, 1=completely rusty<br /> *   RustBump - controls the &quot;bumpiness&quot; of the rusty areas.<br /> *<br /> * ANTIALIASING:<br /> *   The fractal sum used to determine the rust pattern chooses a number of<br /> *   octaves to sum based on the shader sampling rate.  This helps to keep<br /> *   aliasing under control.<br /> *<br /> * AUTHOR: Larry Gritz, gritz AT seas DOT gwu DOT edu <br /> *         The George Washington University<br /> *<br /> * HISTORY:<br /> *   19 Jan 1995 - gritz - created<br /> *<br /> *   modified 19 Jan 95 <br /> *   converted to OSL by Charlie - Dec 2012<br /> *   Renamed input variables by Shane Ambler 21/1/2013<br /> *<br /> */<br /><br />#include &quot;stdosl.h&quot;<br /><br />/* Signed noise varies from -1 to 1 (like Perlin uses) */<br />#define snoise(x) (2*noise(x)-1)<br /><br />/* Maximum number of octaves */<br />#define MAXOCTAVES 8<br /><br /><br />surface<br />LGRustyMetal (<br />        point Vector = P,<br />        float Diffuse = 1.0, <br />        float Roughness = 0.1,<br />        float Scale = 1.0,<br />        float RustAmt = 0.2,<br />        color RustColor = color (0.437, 0.084, 0.0),<br />        float RustDiffuse = 1.0,<br />        float RustBump = 0.035,<br />        output closure color BSDF = diffuse(N) )<br />{<br />  point V;                     /* normal and view vector used for shading */<br />  point Nrust;                 /* perturbed normal for the rusty areas */<br />  point PP;                    /* shade space point */<br />  float i, sum = 0, a = 1;     /* Loop control for fractal sum */<br />  float alimit;                /* Limit sum to do simple antialiasing */<br />  float rustiness;             /* Result: how rusty is this point? */<br />  closure color Cmetal = 0; <br />  closure color Crust = 0; /* Computed colors of metal &amp; rust */<br /><br />  /* Sum several octaves of abs(snoise), i.e. turbulence.  Limit the<br />   * number of octaves by the estimated change in PP between adjacent<br />   * shading samples.<br />   */<br />  PP = Scale * Vector;<br />  alimit = sqrt (area(PP));<br />  for (i = 0;  i &lt; MAXOCTAVES  &amp;&amp;  a &gt; alimit;  i += 1) {<br />      sum += a * abs(snoise(PP));<br />      PP *= 2;<br />      a /= 2;<br />    }<br />  /* If it's rusty, also add a high frequency bumpiness to the normal */<br />  Nrust = calculatenormal (P + RustBump * snoise(PP) * normalize(N));<br /><br />  /* Scale the rust appropriately, modulate it by another noise <br />   * computation, then sharpen it by squaring its value.<br />   */<br />  rustiness = step (1-RustAmt, clamp (sum,0,1));<br />  rustiness *= clamp (abs(snoise(PP)), 0, .08) / 0.08;<br />  rustiness *= rustiness;<br /><br />  /* If we have any rust, calculate the color of the rust, taking into<br />   * account the perturbed normal and shading like matte.<br />   */<br />  if (rustiness &gt; 0) {<br />      Crust = RustColor *RustDiffuse * diffuse(Nrust);<br />    }<br />  /* If we have any metal, calculate the color of the metal, using the<br />   * original (smooth) normal and the usual metal illumination model.<br />   */<br />  if (rustiness &lt; 1) {<br /><br />      Cmetal = Diffuse * microfacet_beckmann(N,Roughness);<br />    }<br /><br />  /* Now blend the metal and rust colors depending on the computed value<br />   * of the rustiness.<br />   */<br />    <br />    BSDF = Crust*rustiness + Cmetal*(1-rustiness);<br />    <br />}<br /><br />
		</script>
	</scripts>
</material>