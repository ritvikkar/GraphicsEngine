<?xml version="1.0" encoding="UTF-8"?>
<material view_color="rgb(0.80000, 0.80000, 0.80000)" sample_lamp="True">
	<nodes>
		<node type="OUTPUT_MATERIAL" width="120" loc="300, 300" />
		<node type="BSDF_DIFFUSE" color="rgba(0.80000, 0.80000, 0.80000, 1.0)" roughness="0.0" width="150" loc="98, 302" />
		<node type="VALTORGB" interpolation="EASE" fac="0.5" stops="7" stop1="0.0|rgba(1.0, 0.0, 0.0, 1.0)" stop2="0.16818|rgba(1.0, 0.21223, 0.0, 1.0)" stop3="0.32727|rgba(1.0, 1.0, 0.0, 1.0)" stop4="0.5|rgba(0.0, 1.0, 0.0, 1.0)" stop5="0.66818|rgba(0.0, 0.0, 1.0, 1.0)" stop6="0.83636|rgba(0.07036, 0.0, 0.22322, 1.0)" stop7="1.0|rgba(0.27467, 0.0, 1.0, 1.0)" width="240" loc="-243, 311" />
		<node type="SCRIPT" mode="INTERNAL" script="0" vector="Vector(0.0, 0.0, 0.0)" pattern="9" mixmodex="0" mixmodey="0" offsetx="0.0" offsety="0.0" axis="0" axisangle="0.0" noisetype="0" noisesize="0.0" pingpong="1" count="2" range="3" spline="0.80000" splinesharpness="0.20000" haftonesize="0.10000" sizemultiplier="2.0" frequency="1.0" scalex="4.0" scaley="4.0" halftonesmooth="0.11999" rowmodulos="2" rowshift="0.0" rowshifty="0.0" width="228" loc="-574, 433" />
		<node type="MAPPING" translation="Vector(0.0, 0.0, 0.0)" rotation="Vector(0.0, 0.0, 0.0)" scale="Vector(2.0, 2.0, 2.0)" use_min="False" use_max="False" vector="Vector(0.0, 0.0, 0.0)" width="240" loc="-889, 295" />
		<node type="TEX_COORD" dupli="False" width="150" loc="-1077, 113" />
	</nodes>
	<links>
		<link to="0" input="0" from="1" output="0" />
		<link to="2" input="0" from="3" output="2" />
		<link to="1" input="0" from="2" output="0" />
		<link to="3" input="0" from="4" output="0" />
		<link to="4" input="0" from="5" output="2" />
	</links>
	<scripts>
		<script name="ChPatterns.osl" id="0">
/*<br /> * ChPatterns.osl by Charlie (c)2012<br /> * from https://github.com/sambler/osl-shaders<br /> *<br /> * original script from -<br /> * http://blenderartists.org/forum/showthread.php?270332-OSL-Goodness/page12<br /> *<br /> */<br /><br />/**<br />Pattern_texture_halftone_v2 by Charlie<br /><br />Pattern selects the dot type<br />Axis is a switch to set the Axis to the centre of the pattern area. (Shifts the texture)<br />Scale and Frequency do the same thing but it is useful to have the two inputs so one can be driven.<br />Size is equivalent to the width of the halftone dot.<br />SizeMultiplier adds additional control, so one can be driven.<br /><br />Halftone returns the halftone.<br />Texture returns the texture used to generate the halftone.<br />X &amp; Y return the texture coordinates.<br /><br />Pattern -- changes the base pattern<br />MixMode -- alters the x/y mixing<br />Offset -- shifts the x/y coords<br />Axis -- shifts origin<br />AxisAngle -- rotates texture cell<br />Noise -- warps texture, use size to turn it on and off<br />PingPong -- flips the cell according to the Modulos setting, which is best kept at 2<br />Count -- spiral arms on spiral pattern only<br />Range -- restricts texture to x no grayscale<br />Spline -- repeats the texture, use SplineSharpness to change the mapping<br />HaftoneSize -- sets the threshold for the halftone<br />SizeMultiplier -- use this to drive the halftone size<br />Frequency -- no of cells<br />ScaleX &amp; ScaleY -- sets frequency of x/y respectively<br />HalftoneSmooth -- controls the change from black to white<br />RowShift -- shifts x/y alternate rows based on modulos setting<br /><br />*/<br /><br />#include &quot;stdosl.h&quot;<br />#include &quot;node_texture.h&quot;<br /><br />shader ChPatterns(<br />    vector Vector = P,<br />    int Pattern = 0,<br />    int MixModeX = 0,<br />    int MixModeY = 0,<br />    float OffsetX = 0,<br />    float OffsetY = 0,<br />    int Axis = 0,<br />    float AxisAngle = 0,<br />    int NoiseType = 0,<br />    float NoiseSize = 0,<br />    int PingPong = 0,<br />    int Count = 0,<br />    int Range = 0,<br />    float Spline = 0,<br />    float SplineSharpness = 0.33,<br />    float HaftoneSize = 0.5,<br />    float SizeMultiplier = M_SQRT2,<br />    float Frequency = 8,<br />    float ScaleX = 1,<br />    float ScaleY = 1,<br />    float HalftoneSmooth = .02,<br />    int RowModulos = 2,<br />    float RowShift = 0,<br />    float RowShiftY = 0,<br />    output float Y = 0,<br />    output float X = 0,<br />    output float Texture = 0,<br />    output float Halftone = 0)<br />{<br /><br />    float mixmode(int mode, float a, float b)<br />    {<br /><br />        if (!mode) {<br />            return a;<br />        }<br />        else<br />        {<br />            if (mode == 1) {<br />                return max(a,b);<br />            }<br />            else if (mode == 2) {<br />                return min(a,b);<br />            }<br />            else if (mode == 3) {<br />                return b;<br />            }<br />            else if (mode == 4) {<br />                return max(a,b)-min(a,b);<br />            }<br />            else if (mode == 5){<br />                return sqrt(a*b);<br />            }<br />            else if (mode == 6){<br />                return cos(a);<br />            }<br />        }<br /><br />    }<br /><br />    void calc_coordinate_modulation(output float X, output float Y,  float NoiseSize, int NoiseType)<br />    {<br /><br />        string nType = &quot;perlin&quot;;<br /><br />        if (NoiseType == 1) {<br />            nType = &quot;cell&quot;;<br />        }<br />        else if (NoiseType == 2){<br />            nType = &quot;uperlin&quot;;<br />        }<br />        else if (NoiseType ==3){<br />            float da[4];<br />            point pa[4];<br /><br />            voronoi(Vector * NoiseSize, &quot;Distance Squared&quot;, 1.0, da, pa);<br /><br />            X += fabs(da[0]);<br />            Y += fabs(da[1]);<br />            return;<br />         }<br />        float nX = NoiseSize * X;<br />        float nY = NoiseSize * Y;<br /><br />        X+= noise(nType,nX,nY);<br />        Y+= noise(nType,nX,nY);<br /><br />        /* transform coordinates with noise functions */<br /><br />    }<br /><br />    void calc_origin_rotation(output float X, output float Y, float angle)<br />    {<br />        /* XXX hmm must be an equivalent function defined elsewhere? */<br />        float temp, costheta, sintheta;<br /><br />        costheta= cos(angle);<br />        sintheta= sin(angle);<br /><br />        temp= X * costheta - Y * sintheta ;<br />        Y= X * sintheta + Y * costheta ;<br />        X= temp;<br /><br />    }<br /><br />    float posterise(float v, float range)<br />    {<br />        /* force value into range */<br />        if( range &gt; 1 ) {<br />            return min(floor(v * range) / (range), 1.0);<br />        }<br />        else if(range == 1) {<br />             return (v &gt; 0.5) ? 1 : 0;<br />        }<br />        else  {<br />            return v;<br />        }<br />    }<br /><br /><br />    float calc_tile_coords(float n)<br />    {<br />        /* force x,y into 0-1 blocks */<br />        if (n &lt; 0.0) {<br />            return 1.0-mod(abs(n),1.0);<br />             } else {<br /><br />            return mod(n, 1.0);<br />        }<br />    }<br /><br />    void centre_axis()<br />    {<br />        /* generate texture origin based on 0,0 -1 to 1 */<br />        X= X*2-1;<br />        Y= Y*2-1;<br />    }<br /><br />    float ping_pong(float in)<br />    {<br />        /* reverses coordinates every other pattern */<br />        int i= 0;<br />        i= (int)ceil(in);<br />        if (in &gt; 1.0) {<br />            if ( i % 2 == 0 ) {<br />                in= mod(in,1);<br />                in= 1-in;<br />            }<br />            else {<br />                in= mod(in,1);<br />            }<br />        }<br /><br />        return in;<br />    }<br /><br />    /* set coords X Y */<br /><br /><br /><br />    X= Vector[0] * ScaleX * Frequency;<br />    Y= Vector[1] * ScaleY * Frequency;<br /><br />    if (NoiseSize &gt; 0.000001) calc_coordinate_modulation(X,Y,NoiseSize,NoiseType);<br /><br />    /* remember odd even rows */<br />    float oddX = (int)floor(X) % RowModulos == 0 ? 1 : 0;<br />    float oddY = (int)floor(Y) % RowModulos == 0 ? 1 : 0;<br /><br /><br />    if (oddY &amp;&amp; RowShift)<br />        X += RowShift;<br /><br />    if (oddX &amp;&amp; RowShiftY)<br />        Y += RowShiftY;<br /><br />    X += OffsetX;<br />    Y += OffsetY;<br /><br />    X = calc_tile_coords(X);<br />    Y = calc_tile_coords(Y);<br /><br /><br /><br />    /* inverse or ping pong alternate rows */<br />    if (oddX == 1 &amp;&amp; ( PingPong == 1 || PingPong == 2)  )<br />            X= 1.0-X;<br /><br />    if (oddY ==1 &amp;&amp; ( PingPong == 1 || PingPong == 3) )<br />            Y= 1.0-Y;<br /><br />    if (Axis == 0)<br />        centre_axis();<br /><br />    if (AxisAngle)<br />        calc_origin_rotation(X,Y,AxisAngle*M_PI_2);<br /><br />    X= mixmode(MixModeX,X,Y);<br />    Y= mixmode(MixModeY,Y,X);<br /><br />    if (Pattern == 1){<br />        Texture= max(abs(X),abs(Y)); /* square */<br />    }<br />    else if (Pattern == 2){<br />        Texture= (abs(X)+abs(Y))/2; /* diamond */<br />    }<br />    else if (Pattern == 3){<br />        Texture= (atan2(abs(Y),X) / (2*M_PI))*2; /* cone */<br />    }<br />    else if (Pattern == 4){<br />        Texture= (X+Y)/2; /* triangle */<br />    }<br />    else if (Pattern == 5){<br />        Texture= (X+1)/2; /* linear x */<br />    }<br />    else if (Pattern == 6){<br />        Texture= (Y+1)/2; /* linear y */<br />    }<br />    else if (Pattern == 7){<br />        Texture= atan(abs(X))+atan(abs(Y));; /* cross */<br />    }<br />    else if (Pattern == 8 || Pattern == 9){<br /><br />        float angleshift= Frequency/360;<br />        float t, r;<br /><br />        if (Pattern == 8 ){                                        //spiral<br />            float t= (atan2(Y,X)+M_2PI)/M_PI;                      //angle<br />            float r= log(sqrt(X*X+Y*Y)*Frequency*Frequency+1.0);   //scale<br />            t*= Count*0.5;                                         //arms<br />            Texture= fmod(t+r+angleshift,1.0);                     //spiral<br />        }<br />        else{                                                      //archimedes (even)<br />            t= (atan2(Y,X)+M_2PI)/M_PI;                            //angle<br />            r= sqrt(X*X+Y*Y)*Frequency;                            //scale<br />            t*= Count*0.5;                                         //arms<br />            Texture= fmod(t+r+angleshift,1.0);                     //archimedes<br />        }<br />    }<br />    else if (Pattern == 10){<br /><br />        Texture= (atan2(Y,X) / (2*M_PI) + 0.5); /* test */<br />    }<br />    else{<br />        Texture= X*X+Y*Y; /* circle */<br />    }<br /><br />    if (Spline &gt; 0.01){<br />            Texture *= Spline;<br />            float sharpness = clamp(SplineSharpness,-1.0,1.0);<br />            Texture = mod(Texture,1.0);<br />            float points[5]={0.0, sharpness, 1.0, sharpness, 0.0};<br />            Texture = spline (&quot;linear&quot;, Texture, 5, points);<br />    }<br /><br />    Texture = clamp(Texture,0.0,1.0);<br /><br />    if (Range &gt; 0)<br />        Texture = posterise(Texture, Range);<br /><br />    /* compare R to the dot size */<br />    float Threshold = HaftoneSize*SizeMultiplier;<br /><br />    if (HalftoneSmooth) {<br />        if (Texture &gt; Threshold) Halftone= smoothstep(0,Texture*2,HalftoneSmooth);<br />        else Halftone= 1;<br />    } else {<br />        if (Texture &gt; Threshold) Halftone= 0;<br />        else Halftone= 1;<br />    }<br />}<br /><br />
		</script>
	</scripts>
</material>