<?xml version="1.0" encoding="UTF-8"?>
<material view_color="rgb(0.80000, 0.80000, 0.80000)" sample_lamp="True">
	<nodes>
		<node type="BSDF_DIFFUSE" color="rgba(0.80000, 0.80000, 0.80000, 1.0)" roughness="0.0" loc="-139, 272" />
		<node type="TEX_COORD" dupli="False" loc="-1183, 120" />
		<node type="BSDF_GLOSSY" distribution="BECKMANN" color="rgba(0.80000, 0.80000, 0.80000, 1.0)" roughness="0.20000" loc="-144, 140" />
		<node type="REROUTE" loc="-222, 170" />
		<node type="BUMP" strength="0.01999" loc="-377, 138" />
		<node type="REROUTE" loc="10, 306" />
		<node type="MIX_SHADER" fac="0.5" loc="87, 304" />
		<node type="OUTPUT_MATERIAL" loc="281, 299" />
		<node type="SCRIPT" mode="INTERNAL" script="0" vector="Vector(0.0, 0.0, 0.0)" lightwood="rgba(0.62310, 0.24742, 0.08178, 1.0)" darkwood="rgba(0.04378, 0.02400, 0.01000, 1.0)" sharpness="0.31000" ringy="1.30000" ringfreq="8.0" ringunevenness="3.0" ringnoise="0.21999" ringnoisefreq="0.30000" grainy="0.80000" grainfreq="18.0" trunkwobble="3.0" trunkwobblefreq="5.0" angularwobble="1.79999" angularwobblefreq="0.80000" loc="-701, 345" />
		<node type="MAPPING" translation="Vector(0.0, 0.0, 0.0)" rotation="Vector(0.0, 0.0, 0.0)" scale="Vector(15.0, 15.0, 15.0)" use_min="False" use_max="False" vector="Vector(0.0, 0.0, 0.0)" loc="-983, 222" />
	</nodes>
	<links>
		<link to="6" input="1" from="0" output="0" />
		<link to="7" input="0" from="6" output="0" />
		<link to="6" input="2" from="2" output="0" />
		<link to="6" input="0" from="5" output="0" />
		<link to="2" input="2" from="4" output="0" />
		<link to="0" input="2" from="4" output="0" />
		<link to="9" input="0" from="1" output="2" />
		<link to="2" input="1" from="3" output="0" />
		<link to="0" input="0" from="8" output="0" />
		<link to="5" input="0" from="8" output="1" />
		<link to="0" input="1" from="8" output="2" />
		<link to="3" input="0" from="8" output="2" />
		<link to="4" input="1" from="8" output="3" />
		<link to="8" input="0" from="9" output="0" />
	</links>
	<scripts>
		<script name="MAWoodGrain.osl" id="0">
/*<br /> * MAWoodGrain.osl by Michel J. Anders (c)2012<br /> * from https://github.com/sambler/osl-shaders<br /> *<br /> * license: cc-by-sa<br /> *<br /> * original script from -<br /> * http://blenderthings.blogspot.com.au/2013/01/an-osl-wood-shader-for-blender-cycles.html<br /> *<br /> */<br /><br />#include &quot;stdosl.h&quot;<br /><br />// for the original renderman shader, check http://www.larrygritz.com/arman/materials.html<br /><br />// adapted from larry gritz advanced renderman patterns.h<br />float smoothpulse (float e0, float e1, float e2, float e3, float x)<br />{<br />    return smoothstep(e0,e1,x) - smoothstep(e2,e3,x);<br />}<br /><br />/* A pulse train of smoothsteps: a signal that repeats with a given<br /> * period, and is 0 when 0 &lt;= mod(x/period,1) &lt; edge, and 1 when<br /> * mod(x/period,1) &gt; edge.<br /> */<br />float smoothpulsetrain (float e0, float e1, float e2, float e3, float period, float x)<br />{<br />    return smoothpulse (e0, e1, e2, e3, mod(x,period));<br />}<br /><br />// adapted from larry gritz advanced renderman noises.h<br />/* fractional Brownian motion<br /> * Inputs:<br /> *    p     position<br /> *    octaves        max # of octaves to calculate<br /> *    lacunarity     frequency spacing between successive octaves<br /> *    gain           scaling factor between successive octaves<br /> */<br /><br />/* A vector-valued antialiased fBm. */<br />vector vfBm (point p, float octaves, float lacunarity, float gain)<br />{<br />    float amp = 1;<br />    point pp = p;<br />    vector sum = 0;<br />    float i;<br /><br />    for (i = 0;  i &lt; octaves;  i += 1) {<br />        vector d = snoise(pp);<br />        sum += amp * d;<br />        amp *= gain;<br />        pp *= lacunarity;<br />    }<br />    return sum;<br />}<br /><br />// adapted from larry gritz oak.sl and oak.h<br />// original comments between /* ... */<br />// my comments start with //<br />// note that I dropped the whole filterwidth stuff, partly<br />// because I don't think it necessary in Blender Cycles, partly<br />// because the derivatives and area() function doesn't seem to work (yet)<br />// all specialized snoise defines are replaced by snoise() function calls<br />float oaktexture (point Pshad,<br />    float dPshad,<br />    float ringfreq,<br />    float ringunevenness,<br />    float grainfreq,<br />    float ringnoise,<br />    float ringnoisefreq,<br />    float trunkwobble,<br />    float trunkwobblefreq,<br />    float angularwobble,<br />    float angularwobblefreq,<br />    float ringy,<br />    float grainy)<br />{<br />    /* We shade based on Pshad, but we add several layers of warping: */<br />    /* Some general warping of the domain */<br />    vector offset = vfBm(Pshad*ringnoisefreq, 2, 4, 0.5);<br /><br />    point Pring = Pshad + ringnoise*offset;<br />    /* The trunk isn't totally steady xy as you go up in z */<br />    vector d = snoise(Pshad[2]*trunkwobblefreq) ;<br />    Pring += trunkwobble * d * vector(1,1,0);<br /><br />    /* Calculate the radius from the center. */<br />    float r = hypot(Pring[0], Pring[1]) * ringfreq;<br />    /* Add some noise around the trunk */<br />    r += angularwobble * smoothstep(0,5,r)<br />    * snoise (angularwobblefreq*(Pring)*vector(1,1,0.1));<br /><br />    /* Now add some noise so all rings are not equal width */<br />    r += ringunevenness*snoise(r);<br /><br />    float inring = smoothpulsetrain (0.1, 0.55, 0.7, 0.95, 1, r);<br /><br />    point Pgrain = Pshad*grainfreq*vector(1,1,0.05);<br />    float dPgrain = dPshad; //dropped filterwidthp(Pgrain);<br />    float grain = 0;<br />    float i, amp=1;<br />    for (i = 0;  i &lt; 2;  i += 1) {<br />    float grain1valid = 1-smoothstep(0.2,0.6,dPgrain);<br />        if (grain1valid &gt; 0) {<br />            float g = grain1valid * snoise (Pgrain);<br />            g *= (0.3 + 0.7*inring);<br />            g = pow(clamp(0.8 - (g),0,1),2);<br />            g = grainy * smoothstep (0.5, 1, g);<br />            if (i == 0)<br />                inring *= (1-0.4*grain1valid);<br />            grain = max (grain, g);<br />        }<br />        Pgrain *= 2;<br />        dPgrain *= 2;<br />        amp *= 0.5;<br />    }<br /><br />    return mix (inring*ringy, 1, grain);<br />}<br /><br />// larry gritz' original shader was a closure but this shader<br />// provides different outputs that you can plug into your own<br />// closures/shaders<br />surface oak(<br />        point Vector = P,<br />        color LightWood = color(0.5, 0.2, 0.067),<br />        color DarkWood = color(0.15, 0.077, 0.028),<br />        float Sharpness = 0.01, // sharpness of the grain. hand tweaked because we lack derivatives.<br />        float Ringy = 1.0,<br />        float RingFreq = 8.0,<br />        float RingUnevenness = 0.5,<br />        float RingNoise = 0.02,<br />        float RingNoiseFreq = 1.0,<br />        float Grainy = 1.0,<br />        float GrainFreq = 25.0,<br />        float TrunkWobble = 0.15,<br />        float TrunkWobbleFreq = 0.025,<br />        float AngularWobble = 1.0,<br />        float AngularWobbleFreq = 1.5,<br />        output color Color = 0,<br />        output float Specular = 0.1,<br />        output float Roughness = 0.1,<br />        output float Displacement = 0.0  )<br />{<br />    float wood = oaktexture (Vector, Sharpness, RingFreq, RingUnevenness, GrainFreq,<br />            RingNoise, RingNoiseFreq, TrunkWobble, TrunkWobbleFreq,<br />            AngularWobble, AngularWobbleFreq, Ringy, Grainy);<br /><br />    Color = mix (LightWood, DarkWood, wood);<br />    Displacement = -wood;  // lightwood = 0, darkwood is deeper/lower = -1<br />    Specular = 0.1*(1.0-0.5*wood); // darkwood is less specular<br />    Roughness = 0.1+0.1*wood; // and rougher<br />}<br /><br />
		</script>
	</scripts>
</material>